#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

######################################################################

set -e

usage (){
    cat <<'EOF'
distbb - DISTributed Bulk Builds for pkgsrc

usage: distbb -h
       distbb -V
       distbb [OPTIONS]
       distbb -r -B <BUILDID> [OPTIONS]
OPTIONS:
  -h|--help              display this help message
  -V|--version           distbb version
  -C|--config <config>   config file, the default is
                         @sysconfdir@/distbb.conf
  -p|--pkgs <packages>   build the specified packages
                         (implies -x summary -x checksum -x upload_pkgs)
  -f|--file <filename>   build the packages listed in
                         the specified filename ( - for stdin),
                         by default all packages from pkgsrc source tree
                         are built
                         (implies -x summary -x checksum -x upload_pkgs)
  -k                     skip updating pkg_src_summary
  -K                     skip updating pkg_summary
  -D|--diff              show difference with previous bulk build
  -B <build_id>          set BUILD_ID (for debugging purposes)
  -r|--retry             if your bulk build failed for some reason, you
                         can try to continue it from the point it stopped at
  -s|--strict            exit status is 0, if ALL packages succeded,
                         or 5 otherwise
  -l <label>             label for bulk build, unless -B option is applied
                         bulk build file will be stored
                         in $REPORTS_DIR/$BUILD_ID-<label> directory
  -x <stage>             exclude <stage> from BUILD_STAGES.
                         Multiple -x are allowed.
                         "-x upload" is equivalent to
                         "-x upload_logs -x upload_pkgs".
  -X <stage>             enable <stage> (antonym for -x)
EOF
}

partial_bb (){
    exclude_state_summary=1
    exclude_state_checksum=1
    exclude_state_upload_pkgs=1
}

exclude (){
    eval "exclude_state_$1=1"
}

unexclude (){
    unset "exclude_state_$1" || true
}

process_args (){
    alt_getopt \
	'h help'       'usage; exit 0' \
	'V version'    'echo distbb-@version@; exit 0' \
	'=f file'      'partial_bb; export pkgs_fn=' \
	'=p pkgs'      'partial_bb; pkgs=' \
	'=C config'    DISTBB_CONF= \
	'D diff'       'export DISTBB_DIFF=1' \
	=B             BUILD_ID= \
	=l             label= \
	k              skip_updating_src_summary=1 \
	K              skip_updating_summary=1 \
	=x             'exclude ' \
	=X             'unexclude ' \
	r              retry=1 \
	s              strict=1 \
	-- "$@"
}
cmds=`process_args "$@"`
eval "$cmds"
if test $# -ne 0; then
    usage
    exit 1
fi

exclude_state_upload_pkgs="${exclude_state_upload_pkgs}${exclude_state_upload}"
exclude_state_upload_logs="${exclude_state_upload_logs}${exclude_state_upload}"

if test -n "$pkgs"; then
    export pkgs_fn=`mktemp /tmp/distbb.XXXXXX`
    test -n "$pkgs_fn"
    trap "rm -f $pkgs_fn" 0 1 2 15

    for p in $pkgs; do
	printf "%s\n" $p >> $pkgs_fn
    done
fi

if test -n "$retry" && test -z "$BUILD_ID"; then
    echo '-r option needs -B' 1>&2
    exit 1
fi

######################################################################

. @bindir@/pipestatus

# date start for placint it to html/txt report
build_start="$(date -u '+%Y-%m-%d %H:%M') UTC"
# date start in YYYYMMDD-HHMM format
if test -z "$BUILD_ID"; then
    BUILD_ID="$(echo $build_start | awk '{gsub(/[:-]/, ""); print $1 "." $2}')"
    if test -n "$label"; then
	BUILD_ID="$BUILD_ID-$label"
    fi
fi

echo "BUILD_ID: $BUILD_ID" 1>&2

DISTBB_CONF=${DISTBB_CONF:-@sysconfdir@/distbb.conf}
. "$DISTBB_CONF"
. @libexecdir@/common

export DISTBB_CONF
######################################################################
test_var (){
    set +e # workaround for buggy Korn Shell ('set -e' + if + eval + false)
    if eval "test -z \"\$$1\""; then
	printf "Variable $1 is unset\n", "$1" 1>&2
	exit 1
    fi
    set -e
}

test_var BMAKE
test_var PKGSRCDIR
test_var PKGSRC_PREFIX
test_var RMDIRS_CMD
test_var EXTRACT_BOOTSTRAP_CMD
test_var PACKAGES
test_var PKG_ALL_SUMMARY
test_var PKG_UPDATE_ALL_SUMMARY_CMD
test_var PKG_SUMMARY
test_var PKG_SRC_SUMMARY
test_var PKG_UPDATE_SRC_SUMMARY_CMD
test_var PKG_CMP_SUMMARY_CMD
test_var REPORTS_DIR
test_var PKG_SUFX
test_var CLEAN_TARGET
test_var TARGETS
test_var DISTBB_SLAVE
test_var OFFENDERS_CNT
test_var MAX_FAILED_DEPS_CNT
test_var REPORT_CMD
test_var UPLOAD_PKGS_PROG
test_var UPLOAD_LOGS_PROG
test_var LIST_ALL_PKGS_CMD
test_var DISTBB_LOCAL_MK
test_var MSCOMMONDIR

if test "$MAIL_PROG" != ':'; then
    test_var USER_MAIL
fi
if test -n "$MASTER_MODE"; then
    test_var SLAVES
    test_var PSS_SLAVES
fi
if test "$UPLOAD_LOGS_PROG" != ':'; then
    test_var UPLOAD_LOGS_DEST
fi
if test "$UPLOAD_PKGS_PROG" != ':'; then
    test_var UPLOAD_PKGS_DEST
fi

if grep BUILD_START "$DISTBB_CONF" > /dev/null; then
    echo 'Replace BUILD_START variable with BUILD_ID in your distbb.conf!' 1>&2
    exit 1
fi

if test "$PKG_ALL_SUMMARY" = "$PKG_SUMMARY"; then
    echo 'PKG_ALL_SUMMARY and PKG_SUMMARY must not be equal' 1>&2
    exit 1
fi

if test "$I_AM_READY" -ne 4 2>/dev/null; then
    echo 'Read NEWS file! Your distbb.conf needs to be updated ;-)' 1>&2
    exit 1
fi

######################################################################

# exporting variables for stage_init
export skip_updating_src_summary
export skip_updating_summary
export build_start

#
for stage in init $BUILD_STAGES; do
#    echo stage=$stage 1>&2

    if echo "$stage" | grep '^/' > /dev/null; then
	stage_fn="$stage"
	stage=$(basename $stage)
    else
	stage_fn="@libexecdir@/stage_$stage"
    fi

    eval x='$'exclude_state_$stage
    if test -n "$x"; then
	continue
    fi

    done_fn=$tmpdir/done_stage_${stage}.tmp
    if test -n "$retry" && test -f ${done_fn}; then
	echo "$stage skipped"
	continue
    fi

    eval ${stage_fn} "$REPORT1_DIR"

    touch ${done_fn}
done

######################################################################

if test -n "$strict"; then
    if test -s "$packages_failed_notavail_fn" ||
	test -s "$packages_failed_scan_fn" ||
	test -s "$packages_failed_fn"
    then
	exit 5
    else
	exit 0
    fi
fi
