#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

######################################################################

set -e
. pipestatus

export LC_ALL=C
######################################################################
tmpdir=/tmp/distbb_build.$$
#trap "rm -rf $tmpdir" 0 1 2 15

mkdir -m 700 $tmpdir

verbose_print (){
    printf "$1" 1>&2
}

######################################################################
set_if_not_set (){
    # $1 - varname
    # $2 - value
    if eval test -z "\$$1"; then
	eval $1="'$2'"
    fi
}

set_if_not_set BMAKE           make
set_if_not_set PKGSRCDIR       /usr/pkgsrc
set_if_not_set PKG_SRC_SUMMARY $PKGSRCDIR/pkg_src_summary.txt
set_if_not_set PACKAGES        $PKGSRCDIR/packages
set_if_not_set PKG_SUMMARY     $PACKAGES/pkg_summary.gz
set_if_not_set PKG_SUFX        .tgz
set_if_not_set REPORTS_DIR     $HOME/bulk-logs
set_if_not_set TARGETS         'clean package checksum build install package'
set_if_not_set TRANSPORT       'ssh -x'

environ="BMAKE=$BMAKE PKGSRCDIR=$PKGSRCDIR REPORTS_DIR=$REPORTS_DIR TARGETS='$TARGETS'"

######################################################################

rm -rf $REPORTS_DIR
mkdir -p $REPORTS_DIR

### extracting DEPENDS and BUILDS_DEPENDS
extract_depends (){
    awk -v deps_fn="$deps_fn" -v bdeps_fn="$bdeps_fn" '
/^PKGNAME=/ {
   pkgname = substr($0, 9)
   next
}

/^PKGPATH=/ {
   pkgpath = substr($0, 9)
   next
}

/^DEPENDS=/ {
   $0 = substr($0, 9)
   gsub(/[^ \t]+:[.][.]\/[.][.]\//, "")

   for (i=1; i <= NF; ++i){
      print pkgname, $i, pkgpath > deps_fn
   }

   next
}

/^BUILD_DEPENDS=/ {
   $0 = substr($0, 15)
   gsub(/[^ \t]+:[.][.]\/[.][.]\//, "")

   for (i=1; i <= NF; ++i){
      print pkgname, $i, pkgpath > bdeps_fn
   }

   next
}

NF == 0 && curr_pkgpath == pkgpath {
   print pkgname
   print deps
   print bdeps
}
' $PKG_SRC_SUMMARY
}

deps_fn=$tmpdir/deps.txt
bdeps_fn=$tmpdir/bdeps.txt

verbose_print "Extracting dependencies from pkg_src_summary file..."
extract_depends
verbose_print "done\n"

######################################################################
### input: graph as a list of arcs
### output: transitive close of this graph
transitive_closure (){
    awk '
# AWK badly suits for this task :-(

BEGIN {
   SUBSEP = " "
}

{
   arc [$1, $2] = 1

   outgoing [$1] = outgoing [$1] " " $2
   incoming [$2] = incoming [$2] " " $1

   nodes [$1] = 1
   nodes [$2] = 1
}

END {
   for (k in nodes){
      cnt_i = split(incoming [k], arr_i)
      for (ii = 1; ii <= cnt_i; ++ii){
         i = arr_i [ii]

         cnt_j = split(outgoing [k], arr_j)
         for (jj = 1; jj <= cnt_j; ++jj){
            j = arr_j [jj]
            if (! ((i SUBSEP j) in arc)){
               arc [i, j] = 1
               incoming [j] = incoming [j] " " i
               outgoing [i] = outgoing [i] " " j
            }
         }
      }
   }

   for (idx in arc){
      print idx
   }
}
' "$@"
}

### unpacking pkg_summary if it is needed
txt_summary=$tmpdir/pkg_summary.txt
if echo $PKG_SUMMARY | grep '[.]gz$' > /dev/null; then
    gzip -dc $PKG_SUMMARY > $txt_summary
    PKG_SUMMARY=$txt_summary
elif echo $PKG_SUMMARY | grep '[.]bz2$' > /dev/null; then
    bzip2 -dc $PKG_SUMMARY > $txt_summary
    PKG_SUMMARY=$txt_summary
fi

### comparison binaries against pkgsrc tree
verbose_print "Comparing pkg_summary and pkg_src_summary files..."
cmp_fn=$tmpdir/cmp.txt
pkg_cmp_summary -p $PKG_SUMMARY $PKG_SRC_SUMMARY > $cmp_fn
verbose_print "done\n"

### direct packages that need to be rebuilt
verbose_print "Generating a list of packages that need to be built..."
rebuild1_fn=$tmpdir/rebuild1.txt
awk '($1 != "=") && ($1 != "-") {print $2}' $cmp_fn | head -100 > $rebuild1_fn
verbose_print "done\n"

### all dependancies (transitive closure)
extract_dep (){
    awk '
NF == 3 {
   print $2, $3
}' "$@"
}

verbose_print "Building transitive closure for the dependancy graph..."
trans_clos_fn=$tmpdir/trans_closure.txt
runpipe0 \
    extract_dep $deps_fn $bdeps_fn '|' \
    transitive_closure > $trans_clos_fn
verbose_print "done\n"

### only those dependancies that depend on packages that need to be rebuilt
filter_rebuild1 (){
    awk -v rebuild1_fn="$rebuild1_fn" '
BEGIN {
   while (getline < rebuild1_fn){
      hash [$1] = 1
   }
}

$1 in hash {
   print $0
}
' "$@"
}

verbose_print "Packages to be built with their full dependancies..."
trans_clos_rebuild_fn=$tmpdir/trans_closure_rebuild.txt
filter_rebuild1 $trans_clos_fn > $trans_clos_rebuild_fn
verbose_print "done\n"

### tsort'ed list of packages
queue_fn=$tmpdir/queue.txt
count_deps (){
awk '
{
   if (NF == 2)
      ++count [$2]
   else
      print $1, 0
}
END {
   for (i in count){
      print i, count [i]
   }
}
' "$@"
}

verbose_print "Initial queue..."
count_deps $rebuild1_fn $trans_clos_rebuild_fn > $queue_fn
verbose_print "done\n"

queue__ready_to_be_built (){
    awk '$2 == 0 {print $1}' $queue_fn
}

### main loop - building
lckfile=$tmpdir/.lock

get_pkgpath (){
    awk -v queue_fn=$queue_fn '
$2 == 0 {
   print $1
   ok = 1
   next
}

{
   print > (queue_fn ".tmp")
}

END {
   exit (ok != 1)
}
' $queue_fn
}

tasks_fn=$tmpdir/tasks.txt
print_tasks (){
    while test -s $queue_fn; do
	while ! shlock -p $$ -f ${lckfile}; do
	    sleep 1 # This is ugly but works
	done

	if get_pkgpath > $tasks_fn; then
	    echo get_pkgpath succeeded 1>&2
	    echo mv ${queue_fn}.tmp $queue_fn 1>&2
	    mv ${queue_fn}.tmp $queue_fn

	    rm ${lckfile}
	    cat $tasks_fn |
	    while read pkgpath; do
		verbose_print "Building package $pkgpath..."
		echo $pkgpath
		verbose_print "done\n"
	    done
	else
	    echo get_pkgpath failed 1>&2
	    rm ${lckfile}
	    sleep 5
	fi
    done
}

print_tasks |
while read pkgpath; do
    mkdir -p $REPORTS_DIR/$pkgpath
    echo $pkgpath
done |
paexec -er -n +1 -c: -t "env $environ queue_fn=$queue_fn ./distbb_slave" |
awk -v reports_dir=$REPORTS_DIR '
$2 == "package:" {
   pkgpath [$1] = $3
   next
}

$2 == "status:" {
   status [$1] = $3
   next
}

{
   fn = reports_dir "/" pkgpath [$1] "/uu.tmp"
}

NF > 1 {
   sub(/^[^ ]+ /, "")
   print > fn
   next
}

{
   close(fn)
   print pkgpath [$1], status [$1]
}
' |
awk \
   -v trans_clos_fn=$trans_clos_rebuild_fn \
   -v queue_fn=$queue_fn \
   -v lckfile=$lckfile \
   -v pid=$$ '
BEGIN {
   while (0 < (ret = (getline < trans_clos_fn))){
      deps [$1, $2] = 1
   }
   if (ret < 0){
      print "reading error from " trans_clos_fn > "/dev/stderr"
   }
   close(trans_clos_fn)

   tmp_fn = (queue_fn ".tmp2")
   wait_for_lock=sprintf("/bin/sh -c \"while ! shlock -p %s -f %s; do sleep 1; done\"", pid, lckfile)
   rm_lock=sprintf("rm %s", lckfile)
   print shlock_cmd
}

$2 == 0 {
   # succeeded
#   print $0 > "/dev/stderr"
   print pkgpath " succeeded" > "/dev/stderr"

   pkgpath = $1

   # getting lock
   if (system(wait_for_lock)){
      print "system(2) failed" > "/dev/stderr"
      exit 76
   }

   # reading counts
   delete counts
   while (0 < (ret = (getline < queue_fn))){
      counts [$1] = $2
   }

   if (ret < 0){
      print "reading error from " queue_fn > "/dev/stderr"
   }
   close(queue_fn)

   # updating counts
   for (i in counts){
      if ((pkgpath SUBSEP i) in deps){
         --counts [i]
      }
   }

   # writing counts
   for (i in counts){
      print i, counts [i] > tmp_fn
   }
   close(tmp_fn)

   # renaming
   if (system("mv " tmp_fn " " queue_fn)){
      print "system(2) failed" > "/dev/stderr"
      exit 2
   }

   # removing lock
   if (system(rm_lock)){
      print "system(2) failed" > "/dev/stderr"
      exit 76
   }

   next
}
'
