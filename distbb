#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

######################################################################

set -e
. pipestatus

export LC_ALL=C # for sort and uniq

######################################################################

verbose_print (){
    printf "$1" 1>&2
}

set_if_not_set (){
    # $1 - varname
    # $2 - value
    if eval test -z "\$$1"; then
	eval $1="'$2'"
    fi
}

######################################################################

set_if_not_set BMAKE           make
set_if_not_set PKGSRCDIR       /usr/pkgsrc
set_if_not_set PKG_SRC_SUMMARY $PKGSRCDIR/pkg_src_summary.txt
set_if_not_set PACKAGES        $PKGSRCDIR/packages
set_if_not_set PKG_SUFX        .tgz
set_if_not_set REPORTS_DIR     $HOME/bulk-logs
set_if_not_set TARGETS         'clean checksum depends build install package delete'
set_if_not_set TRANSPORT       'ssh -x'
set_if_not_set NOTES           ''

set_if_not_set PACKAGES_URL    ''

######################################################################

verbose_print "Preparations\n"

rm -rf $REPORTS_DIR

meta_dir=$REPORTS_DIR/META
tmpdir=$meta_dir/tmp
mkdir -p -m 700 $tmpdir

date_start="$(date -u '+%Y-%m-%d %H:%M') UTC"

packages_failed_deps_fn=$meta_dir/packages_failed_deps.txt
printf '' > $packages_failed_deps_fn

packages_failed_fn=$meta_dir/packages_failed.txt
printf '' > $packages_failed_fn

packages_built_prev_fn=$meta_dir/packages_built_prev.txt
printf '' > $packages_built_prev_fn

packages_built_fn=$meta_dir/packages_built.txt
printf '' > $packages_built_prev_fn

######################################################################

verbose_print "  updating pkg_summary.txt..."
pkg_summary=$PACKAGES/pkg_summary.txt
pkg_update_summary $pkg_summary $PACKAGES
verbose_print "done\n"

######################################################################
### extracting DEPENDS and BUILDS_DEPENDS
extract_depends (){
    awk -v deps_fn="$deps_fn" -v bdeps_fn="$bdeps_fn" '
/^PKGNAME=/ {
   pkgname = substr($0, 9)
   next
}

/^PKGPATH=/ {
   pkgpath = substr($0, 9)
   next
}

/^DEPENDS=/ {
   $0 = substr($0, 9)
   gsub(/[^ \t]+:[.][.]\/[.][.]\//, "")

   for (i=1; i <= NF; ++i){
      deps [$i] = 1
   }
   for (i in deps){
      print pkgname, i, pkgpath > deps_fn
   }
   delete deps

   next
}

/^BUILD_DEPENDS=/ {
   $0 = substr($0, 15)
   gsub(/[^ \t]+:[.][.]\/[.][.]\//, "")

   for (i=1; i <= NF; ++i){
      deps [$i] = 1
   }
   for (i in deps){
      print pkgname, i, pkgpath > bdeps_fn
   }
   delete deps

   next
}

NF == 0 && curr_pkgpath == pkgpath {
   print pkgname
   print deps
   print bdeps
}
' "$PKG_SRC_SUMMARY"
}

deps_fn=$tmpdir/deps.txt
bdeps_fn=$tmpdir/bdeps.txt

verbose_print "  Dependencies from pkg_src_summary file..."
extract_depends
verbose_print "done\n"

######################################################################
### input: graph as a list of arcs
### output: transitive close of this graph
transitive_closure (){
    awk '
# AWK badly suits for this task :-(

BEGIN {
   SUBSEP = " "
}

{
   arc [$1, $2] = 1

   outgoing [$1] = outgoing [$1] " " $2
   incoming [$2] = incoming [$2] " " $1

   nodes [$1] = 1
   nodes [$2] = 1
}

END {
   for (k in nodes){
      cnt_i = split(incoming [k], arr_i)
      for (ii = 1; ii <= cnt_i; ++ii){
         i = arr_i [ii]

         cnt_j = split(outgoing [k], arr_j)
         for (jj = 1; jj <= cnt_j; ++jj){
            j = arr_j [jj]
            if (! ((i SUBSEP j) in arc)){
               arc [i, j] = 1
               incoming [j] = incoming [j] " " i
               outgoing [i] = outgoing [i] " " j
            }
         }
      }
   }

   for (idx in arc){
      print idx
   }
}
' "$@"
}

######################################################################
### comparison binaries against pkgsrc tree
verbose_print "  pkg_summary vs. pkg_src_summary comparison..."
cmp_fn=$tmpdir/cmp.txt
pkg_cmp_summary -p $pkg_summary $PKG_SRC_SUMMARY > $cmp_fn
verbose_print "done\n"

awk '($1 == "=") {print $2}' $cmp_fn \
    > $packages_built_prev_fn

######################################################################
### direct packages that need to be rebuilt
verbose_print "  List of packages to be built..."
rebuild1_fn=$tmpdir/rebuild1.txt
awk '($1 != "=") && ($1 != "-") {print $2}' $cmp_fn |
head -40 > $rebuild1_fn
verbose_print "done\n"

######################################################################
### all dependancies (transitive closure)
extract_dep (){
    awk '
NF == 3 {
   print $2, $3
}' "$@"
}

verbose_print "  Transitive closure of the dependancy graph..."
trans_clos_fn=$tmpdir/trans_closure.txt
runpipe0 \
    extract_dep $deps_fn $bdeps_fn '|' \
    transitive_closure > $trans_clos_fn
verbose_print "done\n"

######################################################################
### only those dependancies that depend on packages that need to be rebuilt
filter_rebuild1 (){
    awk -v rebuild1_fn="$rebuild1_fn" '
BEGIN {
   while (getline < rebuild1_fn){
      hash [$1] = 1
   }
}

$1 in hash {
   print $0
}
' "$@"
}

######################################################################
verbose_print "  Packages to be built with their dependancies..."
trans_clos_rebuild_fn=$tmpdir/trans_closure_rebuild.txt
filter_rebuild1 $trans_clos_fn > $trans_clos_rebuild_fn
verbose_print "done\n"

######################################################################
### counted list of packages / queue
queue_fn=$tmpdir/queue.txt
count_deps (){
awk '
NF == 2 { count [$2] += 1 }
NF == 1 { count [$1] += 0 }
END {
   for (i in count)
      print i, count [i]
}
' "$@"
}

verbose_print "  Initial queue..."
count_deps $rebuild1_fn $trans_clos_rebuild_fn > $queue_fn
verbose_print "done\n"

queue__ready_to_be_built (){
    awk '$2 == 0 {print $1}' $queue_fn
}

######################################################################
verbose_print "  Directories for logging..."
( cd $REPORTS_DIR && awk '{print $1}' $queue_fn | xargs mkdir -p )
verbose_print "done\n"

######################################################################
### main loop - building
lckfile=$tmpdir/.lock

get_pkgpath (){
    awk -v tmp_queue_fn="$queue_fn.tmp" '
$2 == 0 {
   printf "" > tmp_queue_fn
   print $1
   ok = 1
   next
}

{
   print > tmp_queue_fn
}

END {
   exit (ok != 1)
}
' $queue_fn
}

tasks_fn=$tmpdir/tasks.txt
print_tasks (){
    i=0
    while test -s $queue_fn; do
	while ! shlock -p $$ -f ${lckfile}; do
	    sleep 1 # This is ugly but works
	done

	if get_pkgpath > $tasks_fn; then
#	    echo get_pkgpath succeeded 1>&2
	    cp ${queue_fn} $queue_fn.$i.tmp
	    mv ${queue_fn}.tmp $queue_fn
	    i=$(($i+1))

	    rm ${lckfile}
	    cat $tasks_fn
	else
#	    echo get_pkgpath failed 1>&2
	    rm ${lckfile}
	    sleep 5
	fi
    done
}

environ="BMAKE=$BMAKE PKGSRCDIR=$PKGSRCDIR REPORTS_DIR=$REPORTS_DIR TARGETS='$TARGETS'"

postfilter (){
    # postprocessor for paexec's outout.
    # It show progress, suceess and failure messages,
    # redirects build logs to bulk_log/pkgpath directory,
    # recalculates counters in a queue file
    # removes unneeded bulk_log/pkgpath directories etc.
awk \
   -v trans_clos_fn=$trans_clos_rebuild_fn \
   -v queue_fn=$queue_fn \
   -v lckfile=$lckfile \
   -v reports_dir=$REPORTS_DIR \
   -v reports_dir=$REPORTS_DIR \
   -v meta_dir=$meta_dir \
   -v packages_failed_fn=$packages_failed_fn \
   -v packages_built_fn=$packages_built_fn \
   -v pid=$$ '
BEGIN {
   while (xgetline0(trans_clos_fn)){
      deps [$1, $2] = 1
      all_pkgpaths [$1] = 1
      all_pkgpaths [$2] = 1
   }
   xclose(trans_clos_fn)

   tmp_fn = (queue_fn ".tmp2")
   wait_for_lock=sprintf("/bin/sh -c \"while ! shlock -p %s -f %s; do sleep 1; done\"", pid, lckfile)
   rm_lock=sprintf("rm %s", lckfile)
}

!($2 in pkgpaths) {
   pkgpaths [$2] = $3
   print "  started:", $3, "on", $1

   next
}

$3 == "status:" {
   status [$2] = $4
   next
}

{
   log_dir = reports_dir "/" pkgpaths [$2]
   log_fn  = log_dir "/uu.tmp"
}

NF > 2 {
   sub(/^[^ ]+ [^ ]+ /, "")
   print > log_fn
   next
}

# end of task
{
   xclose(log_fn)
}

function xsystem (prog){
   if (system(prog)){
      print "system() failed" > "/dev/stderr"
      exit 1
   }
}

function xclose (fn){
   if (close(fn)){
      print "close(\"" fn "\") failed" > "/dev/stderr"
      exit 1
   }
}

function xgetline0 (fn,                 ret){
   ret = (getline < fn)
   if (ret < 0){
      print "The function getline failed" > "/dev/stderr"
      exit 1
   }
   return (ret > 0)
}

status [$2] == 0 {
   # succeeded
   pkgpath = pkgpaths [$2]

   print "    succeeded:", pkgpath

   #
   print pkgpath >> packages_built_fn
   xclose(packages_built_fn)

   # getting lock
   xsystem(wait_for_lock)

   # reading counts
   delete counts
   while (xgetline0(queue_fn)){
      counts [$1] = $2
   }
   xclose(queue_fn)

   # updating counts
   for (i in counts){
      if ((pkgpath SUBSEP i) in deps){
         --counts [i]
      }
   }

   # writing counts
   printf "" > tmp_fn
   for (i in counts){
      print i, counts [i] > tmp_fn
   }
   xclose(tmp_fn)

   # renaming
   xsystem("mv " tmp_fn " " queue_fn)

   # removing lock
   xsystem(rm_lock)

   # removing log directory
   xsystem("rm -rf " log_dir)

   next
}

function decode_logs (uu,                  txt,fn,dir){
   txt = uu
   sub(/[.][^.\/]*$/, ".txt", txt)

   dir = uu
   sub(/\/[^\/]*$/, "", dir)

   xsystem("uudecode -p < " uu " > " txt)

   #
   fn = ""
   while (xgetline0(txt)){
      if ($1 == "--**--**--" && $3 == "--**--**--"){
         if (fn){
            xclose(fn) # in order to not exceed system/awk limits...
         }

         fn = dir "/stage_" $2 ".txt"
         printf "  " > fn
         continue
      }

      if (fn){
         print > fn
      }else{
         print "this should not happen!" > "/dev/stderr"
      }
   }

   if (fn){
      close(fn) # in order to not exceed system/awk limits...
   }

   xsystem("rm " uu " " txt)
}

{
   # fialed
   pkgpath = pkgpaths [$2]

   print "    FAILED:", pkgpath

   #
   print pkgpath >> packages_failed_fn
   xclose(packages_failed_fn)

   # getting lock
   xsystem(wait_for_lock)

   # decoding logs
   decode_logs(log_fn)

   # reading counts
   delete counts
   while (xgetline0(queue_fn)){
      counts [$1] = $2
   }
   xclose(queue_fn)

   # indirectly failed
   delete indirect_failures
   log_fn  = log_dir "/broken_packages.txt"
   indirect_broken_found = 0
   printf "" >> log_fn
   for (pkgp in all_pkgpaths){
      if ((pkgpath SUBSEP pkgp) in deps){
         indirect_broken_found = 1

         indirect_failures [pkgp] = 1

         pkgp_log_dir = reports_dir "/" pkgp
         pkgp_log_fn  = pkgp_log_dir "/failed_because.txt"
         print pkgpath >> pkgp_log_fn
         xclose(pkgp_log_fn) # in order to not exceed system/awk limits...

         print pkgp > log_fn
      }
   }
   if (indirect_broken_found)
      xclose(log_fn) # in order to not exceed system/awk limits...

   # writing new queue
   printf "" > tmp_fn
   for (i in counts){
      if (! (i in indirect_failures)){
         print i, counts [i] > tmp_fn
      }
   }
   xclose(tmp_fn)

   # renaming
   xsystem("mv " tmp_fn " " queue_fn)

   # removing lock
   xsystem(rm_lock)

   next
}
'
}

verbose_print "Building\n"
runpipe0 \
    print_tasks '|' \
    ~/prjs/paexec/paexec -EI -lr -n +5 -c "env $environ ./distbb_slave" '|' \
    postfilter

######################################################################

verbose_print "Updating pkg_summary.{txt,gz,bz2}..."
pkg_update_summary $pkg_summary $PACKAGES
gzip < $pkg_summary > ${pkg_summary%%.txt}.gz
bzip2 < $pkg_summary > ${pkg_summary%%.txt}.bz2
verbose_print "done\n"

######################################################################

verbose_print "Logs generation and clean-ups..."
rmdir $REPORTS_DIR/* 2>/dev/null || true

date_end="$(date -u '+%Y-%m-%d %H:%M') UTC"
os="$(uname -s) $(uname -r)/$(uname -m)"

path2pkgpath (){
    sed -e 's,^.*/\([^/]*/[^/]*\)/failed_because.txt$,\1,'
}
find_failed_deps_packages (){
    runpipe0 find $REPORTS_DIR -name failed_because.txt '|' path2pkgpath
}

find_failed_deps_packages > $packages_failed_deps_fn

count_lines (){
    awk 'END {print NR}' "$@"
}

right_align (){
   printf "%$1s" "$2"
}

enrich_pkgpath (){
    fields=$1
    shift

    awk -v pkg_src_summary="$PKG_SRC_SUMMARY" -v fields="$fields" -F= '
BEGIN {
   fields = ("PKGPATH " fields)
   cnt=split(fields, n2f, / /)
   for (i=1; i <= cnt; ++i){
      f2n [n2f [i]] = i
   }
}
FILENAME == pkg_src_summary && ($1 in f2n) {
   v [$1] = $2
   next
}
FILENAME == pkg_src_summary && NF == 0 {
   for (f in v){
      value [v["PKGPATH"], f] = v[f]
   }
   delete v
}
FILENAME != pkg_src_summary {
   for (i=1; i <= cnt; ++i){
      printf " %s", value[$1, n2f[i]]
   }
   printf "\n"
}
' "$PKG_SRC_SUMMARY" "$@"
}

get_failed_stage (){
    # $1 - pkgpath
    for t in $TARGETS; do
	if test -f $REPORTS_DIR/$1/stage_$t.txt; then
	    failed_stage="$t"
	fi
    done
    echo $failed_stage
}

print_failed_pkg (){
    # $1 - pkgpath
    # $2 - breaks
    # $3 - stage
    # $4 - maintainer
    # $5 - pkgname
    printf "  <tr><td><a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%-20s</a></td> <td class=\"breaks\">%6s</td> <td>%9s</td> <td align=\"right\">%15s</td> <td align=\"right\">%12s</td></tr>\n" "$1" "$3" "$1" "$1" "$2" "$3" "$4" "$5"
}

print_failed_deps_pkg (){
    # $1 - pkgpath
    # $2 - pkgname
    # $3 - maintainer
    # $4 - dep
    failed_stage=$(get_failed_stage $4)
    printf "  <tr><td>%-22s</td> <td align=\"left\"><a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%22s</a></td><td> %12s</td><td> %-15s</td></tr>\n" "$1" "$4" "$failed_stage" "$4" "$4" "$3" "$2"
}

pkgpath2maintainer (){
    # $1 - pkgpath
    awk -v pkgpath="$1" '$1 == pkgpath {print $2; exit}' $enriched_failed_fn
}

report_txt (){
    cat <<EOF
<h1>pkgsrc bulk build results (distbb - distributed bulk build)</h1>

<h2>$os</h2>

<h3>Summary</h3>

<table><tr>  <td>Build started:</td><td align="right">$(right_align 38 "${date_start}")</td></tr>
  <tr><td>Build ended:</td>  <td align="right">$(right_align 38 "${date_end}")</td></tr>

  <tr><td>&nbsp;</td>                  <td align="right">&nbsp;</td></tr>

  <tr><td>Total packages</td>                  <td align="right">$(right_align 20 $packages_total)</td></tr>
  <tr><td>Packages built previously</td>       <td align="right">$(right_align 20 $packages_built_prev_cnt)</td></tr>
  <tr  class="pkg-built"><td>Packages built</td>                  <td align="right">$(right_align 20 $packages_built_cnt)</td></tr>
  <tr  class="pkg-failed"><td>Packages failed</td>                 <td align="right">$(right_align 20 $packages_failed_cnt)</td></tr>
  <tr  class="pkg-faileddeps"><td>Packages failed due to them</td>     <td align="right">$(right_align 20 $packages_failed_deps_cnt)</td></tr>

  <tr><td>Packages in pkg_summary</td>         <td align="right">$(right_align 20 $packages_in_summary)</td></tr>
</table>
<p>Packages not listed here resulted in a binary package.
Results of failed packages are available below.</p>

<h3>Failed packages</h3>

EOF

    # failed packages
    printf "%s" "<table width=100%>"
    print_failed_pkg "Location" "Breaks" "Stage" "Maintainer" "Package" |
    sed -e 's,<a[^<>]*>,,' \
	-e 's,class="[^"]*",,g' \
	-e 's,[A-Z][a-z ]*,<b>&</b>,g'
    echo ''

    cat $enriched_failed_fn |
    while read pkgpath maintainer pkgname; do
	breaks=$(count_lines $REPORTS_DIR/$pkgpath/broken_packages.txt)
	failed_stage=$(get_failed_stage $pkgpath)
	echo "$pkgpath $breaks $failed_stage $maintainer $pkgname"
    done |
    sort -k2,2nr -k1,1 |
    while read pkgpath breaks failed_stage maintainer pkgname; do
	if test "$breaks" -eq 0; then
	    breaks=''
	fi
	print_failed_pkg "$pkgpath"  "$breaks" "$failed_stage" "$maintainer" "$pkgname"
    done
    printf '%s\n' "</table>"


    # failed dependencies
    echo "<h3>Failed due to dependencies</h3>"

    printf "%s" "<table width=100%>"

    echo ''
    print_failed_deps_pkg 'Location' 'Version' 'Maintainer' \
	'Failed dependencies' |
    sed -e 's,<a[^<>]*>,,' \
	-e 's,[A-Z][a-z ]*,<b>&</b>,g'
    echo ''

    while read pkgpath dummy pkgname; do
	fn=$REPORTS_DIR/$pkgpath/failed_because.txt
	cnt=$(count_lines $fn)
	dep=$(head -1 $fn)
	depX=$(awk -v cnt=$cnt 'NR > cnt-6 && NR > 1' $fn)
	maintainer=$(pkgpath2maintainer "$dep")
	print_failed_deps_pkg "$pkgpath" "$pkgname" "$maintainer" "$dep"
	for dep in $depX; do
	    maintainer=$(pkgpath2maintainer "$dep")
	    print_failed_deps_pkg '' '' "$maintainer" "$dep"
	done
    done < $enriched_failed_deps_fn
    printf "%s\n" "</table>"
}

packages_failed_deps_cnt=$(count_lines $packages_failed_deps_fn)
packages_failed_cnt=$(count_lines $packages_failed_fn)
packages_built_cnt=$(count_lines $packages_built_fn)
packages_built_prev_cnt=$(count_lines $packages_built_prev_fn)
packages_total=$(($packages_built_cnt+$packages_built_prev_cnt))
packages_in_summary=$(awk '{cnt += ($0 ~ /PKGNAME/)} END {print cnt}' $pkg_summary)

enriched_failed_fn=$tmpdir/enriched_failed.txt
enrich_pkgpath "MAINTAINER PKGNAME" \
    $packages_failed_fn > $enriched_failed_fn

enriched_failed_deps_fn=$tmpdir/enriched_failed_deps.txt
enrich_pkgpath "MAINTAINER PKGNAME" \
    $packages_failed_deps_fn > $enriched_failed_deps_fn

html_header (){
    cat <<EOF
<html> <head> <title>$os</title>
<style type="text/css">
<!--

tr {
	Vertical-Align: top;
}

td {
	Vertical-Align: top;
}

h1 {
	Font-Size: 3.5ex;
	Line-Height: 1em;
	Color: #000066;
}

h2 {
	Font-Size: 2.5ex;
	Line-Height: 1em;
	Color: #660000;
}

h3 {
	Font-Size: 2ex;
	Color: #660066;
}

.pkg-built {
	Color: green;
}

.pkg-failed {
	Color: red;
}

.pkg-faileddeps {
	Color: orange;
}

.breaks {
	Color: red;
}

-->
</style>
</head>

<body>

<a name="$1"></a>

EOF
}

html_footer (){
    cat <<EOF
</body>
</html>
EOF
}

report_html (){
    html_header report

    report_txt

    html_footer
}

report_html > $meta_dir/report.html

report_txt | sed -e 's,<[^<>]*>,,g' -e 's,&[a-z]*;,,g' > $meta_dir/report.txt

### generate per file HTMLs
stage2html (){
    html_header

    pkgdir="$(echo $1 | sed 's,/[^/]*$,,')"
    pkgpath="$(echo $1 | sed 's,^.*/\([^/]*/[^/]*\)/[^/]*$,\1,')"
    stage="$(echo $1 | sed 's,^.*stage_\(.*\)[.].*$,\1,')"

    for t in $TARGETS; do
	printf '&nbsp;'

	if test -f $pkgdir/stage_$t.txt; then
	    if test "$t" = "$stage"; then
		printf "$stage"
	    else
		printf "<a href=\"stage_%s.html\" title=\"build log for %s\">%s</a>\n" "$t" "$pkgpath" "$t"
	    fi
	fi

	printf '&nbsp;'
    done
    printf '<br>\n'

    # log itself
    printf "<pre>"
    cat $1
    printf "</pre>"
    html_footer
}

find $REPORTS_DIR -name 'stage_*.txt' |
while read stage_fn; do
    html_fn=${stage_fn%%.txt}.html
    stage2html $stage_fn >$html_fn
done

verbose_print "done\n"

######################################################################
