#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

######################################################################

set -e
. @@bindir@@/pipestatus

# usage: stage_upload_logs BUILD_ID
test $# -eq 1

# init
BUILD_ID="$1"

. @@sysconfdir@@/distbb.conf

REPORT1_DIR=$REPORTS_DIR/$BUILD_ID
. @@libexecdir@@/common

# main
######################################################################
verbose_print "Creating directories for logging..."
cd $REPORT1_DIR
if test -s "$rebuild_fn"; then
    xargs mkdir -p < "$rebuild_fn"
fi
verbose_print "done\n"

######################################################################
### main loop - building

postfilter (){
    # postprocessor for paexec's output.
    # It shows progress, success and failure messages,
    # redirects build logs to bulk_log/pkgpath directory,
    # recalculates counters in a queue file
    # removes unneeded bulk_log/pkgpath directories etc.
runawk \
   -v report1_dir=$REPORT1_DIR \
   -v packages_failed_fn=$packages_failed_fn.raw \
   -v packages_built_fn=$packages_built_fn.raw \
   -v progress_fn=$progress_fn \
   -e '
# input line format:
#    $1 - <SLAVE_HOST>
#    $2 - <TASK_NUMBER>

#use "xclose.awk"
#use "xsystem.awk"

!($2 in pkgpaths) {
   # $3 - package name (PKGPATH)
   pkgpaths [$2] = $3
   run_on   [$2] = $1
   print "  started:", $3, "on", $1

   next
}

$0 ~ /^[^ ]+ [0-9]+ success$/ {
   status [$2] = "success"
   next
}

$0 ~ /^[^ ]+ [0-9]+ failure$/ {
   status [$2] = "failure"
   next
}

status [$2] == "failure" && !($2 in failed_packages) {
   task_number = $2
   $1 = $2 = ""
   failed_packages [task_number] = $0
   next
}

{
   pkgpath = pkgpaths [$2]
   log_dir = report1_dir "/" pkgpath
   log_fn  = log_dir "/stage_" stage [$2] ".tmp"
}

$3 == "--**--**--" && $5 == "--**--**--" {
   if (stage [$2] != ""){
      xclose(log_fn)
   }
   stage [$2] = $4
   printf "" > (log_dir "/stage_" $4 ".tmp")

   next
}

$0 ~ /^[^ ]+ [0-9]+  / {
   # normal log line
   sub(/^[^ ]+ [^ ]+  /, "")
   print > log_fn
   next
}

# end of task
{
   assert(NF == 2, "this should not happen")
   if (stage [$2] != "")
      xclose(log_fn)
}

function free_arrs (task){
   delete pkgpaths [task]
   delete run_on   [task]
   delete status [task]
   delete stage [task]
   delete failed_packages [task]
}

status [$2] == "success" {
   # succeeded
   print "    succeeded:", pkgpath, "on", run_on [$2]

   #
   print pkgpath >> packages_built_fn
   xclose(packages_built_fn)

   # removing log directory
   xsystem("rm -rf " log_dir)

   # free memory
   free_arrs($2)

   #
   print "succeeded", pkgpath >> progress_fn
   xclose(progress_fn)

   #
   next
}

status [$2] == "failure" {
   # failed
   print "    F-A-I-L-E-D:", pkgpath, "on", run_on [$2]

   #
   print pkgpath >> packages_failed_fn
   xclose(packages_failed_fn)

   # indirectly failed
   cnt = split(failed_packages [$2], failed_pkgs)
   log_fn  = log_dir "/failed_packages.txt"
   printf "" > log_fn
   for (i=2; i <= cnt; ++i){
      fpkg = failed_pkgs [i]
      print fpkg > log_fn

      pkgp_log_fn = report1_dir "/" fpkg "/failed_because.txt"
      print pkgpath >> pkgp_log_fn
      xclose(pkgp_log_fn) # in order to not exceed system/awk limits...
   }
   xclose(log_fn)

   # free memory
   free_arrs($2)

   #
   print "failed", pkgpath >> progress_fn
   xclose(progress_fn) # to make stage "build" rerunable

   #
   next
}

{
   abort("this should not happen 2")
}
'
}

if test "$MASTER_MODE"; then
    SLAVES="-n '$SLAVES'"
    TRANSPORT="-t '$TRANSPORT'"
else
    SLAVES='-n +1' # building on localhost
    unset TRANSPORT || true
fi

verbose_print "Building\n"

eval runpipe0 \
    paexec -s -EI -lr $TRANSPORT $SLAVES -c "$DISTBB_SLAVE" < "$queue_fn" '|' \
    postfilter

######################################################################

verbose_print "Updating pkg_summary..."
eval $PKG_UPDATE_SUMMARY_CMD $PKG_SUMMARY $PACKAGES/All
verbose_print "done\n"

######################################################################

echo "$(date -u '+%Y-%m-%d %H:%M') UTC" > $build_end_fn
