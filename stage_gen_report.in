#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

######################################################################

set -e
. @@bindir@@/pipestatus

# usage: stage_gen_report BUILD_ID
test $# -eq 1

# init
BUILD_ID="$1"

DISTBB_CONF=${DISTBB_CONF:-@@sysconfdir@@/distbb.conf}
. "$DISTBB_CONF"
. @@libexecdir@@/common

# main
verbose_print "Logs generation...\n"

sort_uniq_inplace $REPORT1_DIR/META/packages_built.txt.tmp
sort_uniq_inplace $REPORT1_DIR/META/packages_failed.txt.tmp
sort_uniq_inplace $REPORT1_DIR/META/packages_failed_notavail.txt.tmp

build_start=$(cat "$build_start_fn")
build_end=$(cat "$build_end_fn")

find_failed_deps_packages (){
    runpipe0 \
	find "$REPORT1_DIR" -name failed_deps.txt '|' \
	xargs cat '|' sort_uniq
}

find_failed_deps_packages > "$packages_failed_deps_fn.tmp"

# resort failed_because.txt and failed_deps.txt
find $REPORT1_DIR -type f \
    '(' -name failed_because.txt -o -name failed_deps.txt ')' |
while read f; do
    sort_uniq_inplace "$f"
done

# main continuing...
count_lines (){
    awk 'END {print NR}' "$@"
}

left_align (){
   printf "%-$1s" "$2"
}

right_align (){
   printf "%$1s" "$2"
}

get_failed_stage (){
    # $1 - pkgpath
    # $2 - pkgname
    cat "$REPORT1_DIR/$2/curr_stage.tmp"
}

print_failed_pkg (){
    # $1 - pkgpath
    # $2 - breaks
    # $3 - stage
    # $4 - maintainer
    # $5 - pkgname
    short_pkgpath="$(echo $1 | cut -f1 -d:)"
    if test -n "$2" && test "$2" != "Breaks"; then
	__href_beg="`printf '<a href=\"../%s/failed_deps.txt\" title=\"packages failed due to %s\">' $5 $short_pkgpath`"
	__href_end='</a>'
    else
	__href_beg=''
	__href_end=''
    fi

    printf "  <tr><td><a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%-27s</a></td> <td class=\"breaks\">${__href_beg}%7s${__href_end}</td> <td>%11s</td> <td align=\"right\">%27s</td>\n    <td align=\"right\">%-25s</td></tr>\n" "$5" "$3" "$short_pkgpath" "$short_pkgpath" "$2" "$3" "$4" "$5"
}

print_failed_deps_pkg (){
    # $1 - pkgpath
    # $2 - pkgname
    # $3 - maintainer
    # $4 - deppath
    # $5 - depname
    failed_stage=''
    if test "$1" != Package -a -n "$4"; then
	failed_stage=$(get_failed_stage "$4" "$5")
    fi
    short_pkgpath="$(echo $1 | cut -f1 -d:)"
    if test "$short_pkgpath" != "$1"; then
	short_pkgpath="$short_pkgpath($2)"
    fi

    if test -n "$1"; then
	printf "  <tr><td><a href=\"../%s/failed_because.txt\" title=\"failed due to...\">%-42s</a></td> <td> %s</td></tr>\n" "$2" "$short_pkgpath" "$3"
    else
	printf "  <tr><td align=\"left\">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href=\"../%s/stage_%s.html\" title=\"build log for %s\">     %-37s</a></td><td>       %s</td></tr>\n" "$5" "$failed_stage" "$4" "$4" "$3"
    fi
#    printf "  <tr><td>%-26s</td> <td align=\"left\"><a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%-26s</a></td><td> %s</td></tr>\n" "$short_pkgpath" "$5" "$failed_stage" "$4" "$4" "$3"
}

pkgpath2maintainer (){
    # $1 - pkgpath
    awk -v pkgpath="$1" '$1 == pkgpath {print $3; exit}' "$packages_failed_total_fn"
}

pkgpath2pkgname (){
    # $1 - pkgpath
    awk -v pkgpath="$1" '$1 == pkgpath {print $2; exit}' "$packages_failed_total_fn"
}

distbb_diff2html (){
    awk -v report1_dir=$REPORT1_DIR -F'\t' '
function p (progress, pkgpath, pkgbase, version) {
   printf "<tr>%s <td> %s</td><td> %s</td><td> %s</td></tr>\n",
	progress, pkgpath, pkgbase, version
}
BEGIN {
   printf "<table width=\"100%%\">"
   p("<td></td>", "<b>Package</b>", "<b>PKGBASE</b>", "<b>Version(s)</b>")
}
{
   # $1 - result
   # $2 - PKGPATH
   # $3 - PKGBASE
   # $4 - version(s)

   sub(/:.*$/, "", $1) # strip building options

   ver = $4
   sub(/.* /, "", ver)

   if ($1 ~ /^n?-$/){
      stage_fn = report1_dir "/" $3 "-" ver "/curr_stage.tmp"
      getline failed_stage < stage_fn
      close(stage_fn)

      $2 = sprintf("<a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%-27s</a>", $3 "-" ver, failed_stage, $2, $2)

      $1 = "<td class=\"pkg-failed\">" $1 "</td>"
   }else if ($1 ~ /-d$/){
      $2 = sprintf("<a href=\"../%s/failed_because.txt\" title=\"failed due to...\">%-27s</a>", $3 "-" ver, $2)

      $1 = "<td class=\"pkg-faileddeps\">" $1 "</td>"
   }else if ($1 ~ /[+]/){
      $1 = "<td class=\"pkg-built\">" $1 "</td>"
   }else{
      $1 = "<td>" $1 "</td>"
   }
   p($1, $2, $3, $4)

   diff = 1
}
END {
   if (!diff) print "<tr><td>no difference</td></tr>"
   printf "</table>"
}
' "$@"
}

print_distbb_diff_help_msg (){
    cat <<EOF
<p><i>'-' package was built successfully but now fails<br>
'+' package failed previously but now is built successfully<br>
'c' pkg_src_summary failed for given package<br>
'd' package fails/failed due to broken dependency<br>
'N' package is new<br>
'R' package was removed<br>
</i></p>
EOF
}

grep_existing_pkgs (){
    # output packages present in pkg_src_summary
    # $1 - pkg_src_summary filename
    # $2..N - packages (enriched PKGPATHs, i.e. with building options)
    awk -v pkg_src_summary_fn="$1" '
FILENAME != pkg_src_summary_fn {
   if ($1 in pkgpaths){
      print $0
      delete pkgpaths [$1] # first version is higher,
                           # no need for older version
   }
   next
}
$0 ~ /^PKGPATH=/ {
   pkgpaths [substr($0, 9)] = 1
   next
}
' "$@"
}

report_html (){
    if test "$PACKAGES_URL"; then
	url="<a href=\"$PACKAGES_URL\" title=\"binary packages\">binary packages</a>"
    else
	url='binary packages'
    fi

    cat <<EOF
<h1>pkgsrc bulk build results (distbb-$version)</h1>

<h2>$OS $OSVER</h2>

<!--  <p><a href="$REPORT_URL" title="Full report">$REPORT_URL</a></p> -->

EOF

    if test "$RESPONSIBLE"; then
	echo "<p>$RESPONSIBLE</p> <!-- REMOVE ME -->"
    fi

    if test "$NOTES"; then
	echo '<h3><a name="notes"></a>Notes</h3>'
	printf '<p>'
	cat "$NOTES"
	printf '</p>'
    fi

    cat <<EOF

<h3><a name="summary"></a>Summary</h3>

<table><tr>  <td>Build started:</td><td align="right">$(right_align 38 "${build_start}")</td><td>&nbsp;</td></tr>
  <tr><td>Build ended:</td>  <td align="right">$(right_align 38 "${build_end}")</td><td>&nbsp;</td></tr>

  <tr><td>&nbsp;</td>                  <td>&nbsp;</td><td>&nbsp;</td></tr>
  <tr class="pkg-total"><td>$(left_align 40 "Inspected packages")</td><td align="right">$packages_inspected_cnt</td><td></td></tr>
  <tr class="pkg-total"><td>$(left_align 40 "Built packages (total)")</td><td align="right">$packages_built_total</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_built_total_fn)" title="All built packages"> list</a></td></tr>
  <tr><td>&nbsp;&nbsp;  $(left_align 38 "built previously")</td><td align="right">$packages_built_prev_cnt</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_built_prev_fn)" title="Packages built previously"> list</a></td></tr>
  <tr class="pkg-built"><td>&nbsp;&nbsp;  $(left_align 38 "really built")</td><td align="right">$packages_built_cnt</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_built_fn)" title="Successfully built packages"> list</a></td></tr>
  <tr><td>$(left_align 40 "Failed packages (total)")</td><td align="right">$packages_failed_total</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_failed_total_fn)" title="All failed packages"> list</a></td></tr>
  <tr class="pkg-failed"><td>&nbsp;&nbsp;  $(left_align 38 "really failed")</td><td align="right">$packages_failed_cnt</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_failed_fn)" title="Really failed packages"> list</a></td></tr>
  <tr><td>&nbsp;&nbsp;  $(left_align 38 "marked as not available")</td><td align="right">$packages_failed_notavail_cnt</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_failed_notavail_fn)" title="Packages marked as not available"> list</a></td></tr>
  <tr class="pkg-faileddeps"><td>&nbsp;&nbsp;  $(left_align 38 "failed due to them")</td><td align="right">$packages_failed_deps_cnt</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_failed_deps_fn)" title="Packages failed due to dependencies"> list</a></td></tr>
EOF

    if  test "$packages_failed_scan_cnt" -gt 0 ||
	test -s "$build_src_summary_log_fn"
    then
	cat <<EOF
  <tr class="pkg-failed"><td>&nbsp;&nbsp;  $(left_align 38 "pkg_src_summary failed")</td><td align="right">$packages_failed_scan_cnt</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_failed_scan_fn)" title="Packages failed while building pkg_src_summary"> list</a></td> <td>&nbsp;&nbsp;<a href="$(basename $build_src_summary_log_fn)" title="pkg_src_summary logs">logs</a></td></tr>
EOF
    fi

    cat <<EOF
  <tr><td>$(left_align 40 "Packages in pkg_summary")</td><td align="right">$packages_in_summary</td></tr>
</table>
<p>Packages not listed here resulted in a $url.<br>
Results of failed packages are available below.<br>
Progress messages are <a href="$(basename $progress_fn)" title="Progress messages">here</a>.<br> <!-- REMOVE ME -->
pkg_src_summary is <a href="$(basename $pkg_src_summary_fn)" title="pkgsrc source packages summary">here</a>.<br> <!-- REMOVE ME -->
pkg_summary vs. pkg_src_summary <a href="$(basename $summary_cmp_fn)" title="binary packages agains pkgsrc tree">comparison</a>.<br> <!-- REMOVE ME -->
EOF

    cat <<EOF
</p>
<p>Jump to:
<ul>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#failures per maintainer">Failures per maintainer</a></li>
    <li><a href="#failed">Failed packages</a></li>
    <li><a href="#failed depends">Failed due to dependencies</a></li>
    <li><a href="#old vs new">Progress since previous bulk build</a></li>
</ul>

EOF

    # failures per maintainer
    cat <<EOF
<hr>
<h3><a name="failures per maintainer"></a>Failures per maintainer</h3>

EOF
    printf '<table width="30%%">'
    printf '<tr><td>%-36s</td> <td align="right">%4s</td></tr>\n' '<b>Maintainer</b>' '<b>Breaks</b>'
    echo ''

    cat "$packages_failed_fn" |
    while read pkgpath pkgname maintainer; do
	echo "$maintainer $pkgpath"
	awk -v m=$maintainer '
	   { print m, $1}' "$REPORT1_DIR/$pkgname/failed_deps.txt"
    done | sort_uniq |
    awk '{++count [$1]}
    END {for (m in count) print m, count [m] }' |
    sort -k2,2rn |
    head -n "$OFFENDERS_CNT" |
    awk '{
	printf "<tr><td>%-27s</td> <td align=\"right\">%4d</td></tr>\n", $1, $2
    }'

    printf '</table>\n'

    # failed packages
    cat <<EOF
<hr>
<h3><a name="failed"></a>Failed packages</h3>

EOF
    printf '%s' '<table width="100%">'
    print_failed_pkg "Package" "Breaks" "Stage" "Maintainer" "" |
    sed -e 's,<a[^<>]*>,,' \
	-e 's,</a[^<>]*>,,' \
	-e 's,class="[^"]*",,g' \
	-e 's,[A-Z][a-z ]*,<b>&</b>,g'

    cat "$packages_failed_fn" "$packages_failed_notavail_fn" |
    while read pkgpath pkgname maintainer; do
	breaks=$(count_lines "$REPORT1_DIR/$pkgname/failed_deps.txt")
	failed_stage=$(get_failed_stage "$pkgpath" "$pkgname")
	echo "$pkgpath $breaks $failed_stage $maintainer $pkgname"
    done |
    sort -k2,2nr -k1,1 |
    while read pkgpath breaks failed_stage maintainer pkgname; do
	if test "$breaks" -eq 0; then
	    breaks=''
	fi
	print_failed_pkg "$pkgpath"  "$breaks" "$failed_stage" "$maintainer" "$pkgname"
    done
    printf '%s\n' "</table>"

    # failed dependencies
    cat <<EOF
<hr>
<h3><a name="failed depends"></a>Failed due to dependencies</h3>
EOF

    printf '%s' '<table width="100%">'

    echo ''
    print_failed_deps_pkg 'Package/Dependency' '' 'Maintainer' |
    sed -e 's,<a[^<>]*>,,' \
	-e 's,</a[^<>]*>,,' \
	-e 's,[A-Z][a-z ]*,<b>&</b>,g'
    echo ''

    while read pkgpath pkgname maintainer; do
	fn="$REPORT1_DIR/$pkgname/failed_because.txt"
	depX=$(head -n "$MAX_FAILED_DEPS_CNT" "$fn")
	print_failed_deps_pkg \
	    "$pkgpath" "$pkgname" "$maintainer" '' ''
	for deppath in $depX; do
	    maintainer=$(pkgpath2maintainer "$deppath")
	    depname=$(pkgpath2pkgname "$deppath")
	    print_failed_deps_pkg '' '' "$maintainer" "$deppath" "$depname"
	done
    done < "$packages_failed_deps_fn"
    printf '%s\n' "</table>"

    # previous bulk build vs. this one
    if test -n "$DISTBB_DIFF"; then
	if test -f $bb_history_fn; then
	    bbid_prev=$(tail -2 $bb_history_fn | head -1)
	    bbdir_prev="$REPORTS_DIR/$bbid_prev"
	else
	    bbid_prev=''
	    bbdir_prev='/does/not/exist'
	fi

	if test "$bbid_prev" != "$BUILD_ID" &&
	    test -n "$bbid_prev" &&
	    test -d "$bbdir_prev"
	then
	    cat <<EOF
<hr>
<h3><a name="old vs new"></a>Progress: $bbid_prev vs. $BUILD_ID</h3>
EOF
	    print_distbb_diff_help_msg
	    distbb_diff $bbdir_prev $REPORT1_DIR | distbb_diff2html
	fi
    fi

    # virtual "best" bulk build vs. this one
    if test -n "$DISTBB_DIFF"; then
	bbid_best=.best_bb
	bbdir_best="$REPORTS_DIR/$bbid_best"

	best_is_ok=''
	if test -d $bbdir_best -a \
	    -f $bbdir_best/META/packages_built_total.txt -a \
	    -f $bbdir_best/META/pkg_src_summary.txt
	then
	    best_is_ok=1
	fi

	if test -n "$best_is_ok"; then
	    cat <<EOF
<hr>
<h3><a name="best vs new"></a>Progress: virtual "best" bulk build vs. $BUILD_ID</h3>
<p><i>Below '-' means that package was built at least
once in the past, but now fails</i></p>
EOF
	    print_distbb_diff_help_msg
	    distbb_diff $bbdir_best $REPORT1_DIR | distbb_diff2html
	fi

	if test -n "$best_is_ok"; then
	    mv $bbdir_best/META/packages_built_total.txt \
	       $bbdir_best/META/packages_built_total.txt.old
	    mv $bbdir_best/META/pkg_src_summary.txt \
	       $bbdir_best/META/pkg_src_summary.txt.old

	    grep_existing_pkgs \
		$REPORT1_DIR/META/pkg_src_summary.txt \
		$REPORT1_DIR/META/packages_built_total.txt \
		 $bbdir_best/META/packages_built_total.txt.old \
		> $bbdir_best/META/packages_built_total.txt
	else
	    mkdir -p $bbdir_best/META
	    cp $REPORT1_DIR/META/packages_built_total.txt \
	       $bbdir_best/META/
	fi

	cp $REPORT1_DIR/META/pkg_src_summary.txt $bbdir_best/META/
	touch $bbdir_best/META/packages_failed_deps.txt
    fi

    # the end
    printf '<hr>\n'
}

packages_inspected_cnt=$(count_lines "$packages_with_deps_fn")

packages_failed_notavail_cnt=$(count_lines "$packages_failed_notavail_fn.tmp")
packages_failed_scan_cnt=$(count_lines "$packages_failed_scan_fn")
packages_failed_deps_cnt=$(count_lines "$packages_failed_deps_fn.tmp")
packages_failed_cnt=$(count_lines "$packages_failed_fn.tmp")
packages_failed_total=$(($packages_failed_cnt+$packages_failed_prev_cnt+$packages_failed_scan_cnt+$packages_failed_notavail_cnt))

packages_built_cnt=$(count_lines "$packages_built_fn.tmp")
packages_built_prev_cnt=$(count_lines "$packages_built_prev_fn.tmp")
packages_built_total=$(($packages_built_cnt+$packages_built_prev_cnt))

packages_in_summary=$(awk '{cnt += ($0 ~ /^PKGNAME=/)} END {print cnt}' "$PKG_SUMMARY")

##

verbose_print "  enriching META/packages_*.txt..."

runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_built_prev_fn.tmp '|' \
    sort_uniq > $packages_built_prev_fn
runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_built_fn.tmp '|' \
    sort_uniq > $packages_built_fn
runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_failed_fn.tmp '|' \
    sort_uniq > $packages_failed_fn
runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_failed_deps_fn.tmp '|' \
    sort_uniq > $packages_failed_deps_fn
runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_failed_notavail_fn.tmp '|' \
    sort_uniq > $packages_failed_notavail_fn

verbose_print "done\n"

##

verbose_print "  creating META/packages_{built,failed}_total.txt..."

sort_uniq "$packages_built_fn" "$packages_built_prev_fn" \
    > "$packages_built_total_fn"

sort_uniq "$packages_failed_fn" "$packages_failed_deps_fn" \
    "$packages_failed_scan_fn" "$packages_failed_notavail_fn" \
    > "$packages_failed_total_fn"

verbose_print "done\n"

##
html_header (){
    cat <<EOF
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html> <head> <title>$os</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<style type="text/css">
<!--

tr {
	Vertical-Align: top;
}

td {
	Vertical-Align: top;
}

h1 {
	Font-Size: 3.5ex;
	Line-Height: 1em;
	Color: #000066;
}

h2 {
	Font-Size: 2.5ex;
	Line-Height: 1em;
	Color: #660000;
}

h3 {
	Font-Size: 2ex;
	Color: #660066;
}

.pkg-total {
	Color: blue;
}

.pkg-built {
	Color: green;
}

.pkg-failed {
	Color: red;
}

.pkg-faileddeps {
	Color: orange;
}

.breaks {
	Color: red;
}

-->
</style>
</head>

<body>

EOF
}

html_footer (){
    cat <<EOF
</body>
</html>
EOF
}

report_full_html (){
    html_header

    report_html > $REPORT1_DIR/META/tmp/report_body.html
    cat $REPORT1_DIR/META/tmp/report_body.html

    html_footer
}

report_full_html > "$meta_dir/report.html"

report_html2txt (){
   awk '
   /Jump to:/, NF == 0 {
      next
   }
   /REMOVE ME/ {
      next
   }
   {
      gsub(/<hr>/, "---------------------------------------------------------------------------")
      gsub(/<!--|-->/, "")
      gsub(/<[^<>]*>/, "")
      gsub(/&[a-z]*;/, "")
   }
   $2 == "PKGBASE" {
      printf "%-4s %-24s %-20s %24s\n\n", "", $1, $2, $3
      next
   }
   $1 ~ /^[nN]?[-+][dc]?$/ && NF >= 4 || $1 == "R" && NF == 3 {
      sub(/[+]/, "+", $1)
      sub(/[-]/, "-", $1)

      diff    = $1
      pkgpath = $2
      pkgbase = $3
      $1 = $2 = $3 = ""
      vers = substr($0, 4)

      printf "%-4s %-24s %-20s %24s\n", diff, pkgpath, pkgbase, vers
      next
   }
   /^Failed packages/, /------------/ {
      if (NF == 4) printf "  %-35s %6s %-34s\n", $1, $2, $4
      else if (NF == 3) printf "  %-35s %6s %-34s\n", $1, "", $3
      else print $0
      next
   }
   /Summary/, /Failures per/ {
      if (NF > 0 && $NF ~ /^(list|logs)$/)
         gsub(/list|logs/, "")
      if (/Progress messages/)
         next
   }
   { print }
   ' "$@"
}

report_txt_fn="$meta_dir/report.txt"
cat $REPORT1_DIR/META/tmp/report_body.html |
report_html2txt | sed 's| *$||' > "$report_txt_fn"

### generate per package summary.tmp
runawk -v report1="$REPORT1_DIR" -e '
#use "xclose.awk"

NF == 0 {
   summary_dir = report1 "/" pkgname
   if (0 == system("test -d \"" summary_dir "\"")){
      summary_fn = summary_dir "/summary.txt"
      cvrt = ("pkg_summary4view > " summary_fn)
      print substr(summary, 2) | cvrt
      xclose(cvrt)
   }

   summary = pkgname = ""
   next
}
{
   summary = summary "\n" $0
   if ($0 ~ /PKGNAME=/){
      pkgname = substr($0, 9)
   }
}
' "$pkg_src_summary_fn"

### generate stage_xxx HTMLs
other_stages_bar (){
    printf '<p>Stages:&nbsp;'
    for t in $TARGETS; do
	if test -s "$pkgdir/stage_$t.tmp"; then
	    if test "$t" = "$stage"; then
		printf "$stage"
	    else
		printf '<a href="stage_%s.html" title="build log for %s">%s</a>\n' \
		    "$t" "$pkgpath" "$t"
	    fi

	    printf '&nbsp;'
	fi
    done
    short_pkgpath="$(echo $pkgpath | cut -f1 -d:)"
    printf '<br>Summary:<a href="summary.txt" title="summary for package %s">summary</a>' \
	"$short_pkgpath"
    printf '</p>\n'
}

stage2html (){
    html_header

    pkgdir="$(echo $1 | sed 's,/[^/]*$,,')"
    pkgpath="$(echo $1 | sed 's,^.*/\([^/]*/[^/]*\)/[^/]*$,\1,')"
    stage="$(echo $1 | sed 's,^.*stage_\(.*\)[.].*$,\1,')"

    other_stages_bar

    # log itself
    printf "<pre>"
    cat "$1"
    printf "</pre>"

    if test "$(count_lines $1)" -gt 20; then
	other_stages_bar
    fi

    html_footer
}

find "$REPORT1_DIR" -name 'stage_*.tmp' |
while read stage_fn; do
    if test -s $stage_fn; then
	html_fn=${stage_fn%%.tmp}.html
	stage2html "$stage_fn" >"$html_fn"
    fi
done

verbose_print "done\n"
