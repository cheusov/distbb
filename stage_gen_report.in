#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

######################################################################

set -e
. @@bindir@@/pipestatus

# usage: stage_gen_report BUILD_ID
test $# -eq 1

# init
BUILD_ID="$1"

. @@sysconfdir@@/distbb.conf

REPORT1_DIR=$REPORTS_DIR/$BUILD_ID
. @@libexecdir@@/common

# main
verbose_print "Logs generation...\n"

build_start=$(cat "$build_start_fn")
build_end=$(cat "$build_end_fn")

find_failed_deps_packages (){
    runpipe0 \
	find "$REPORT1_DIR" -name failed_packages.txt '|' \
	xargs cat '|' env LC_ALL=C sort -u
}

find_failed_deps_packages > "$packages_failed_deps_fn.raw"

# resort failed_because.txt and failed_packages.txt
find $REPORT1_DIR -type f \
    '(' -name failed_because.txt -o -name failed_packages.txt ')' |
while read f; do
    env LC_ALL=C sort -u $f > $f.tmp
    mv $f.tmp $f
done

# main continuing...
count_lines (){
    awk 'END {print NR}' "$@"
}

right_align (){
   printf "%$1s" "$2"
}

get_failed_stage (){
    # $1 - pkgpath
    # $2 - pkgname
    failed_stage_fn="$REPORT1_DIR/$2/failed_stage.tmp"
    if ! test -d "$REPORT1_DIR/$2"; then
	echo ''
	return
    fi

    if test -f "$failed_stage_fn"; then
	cat "$failed_stage_fn"
	return
    fi

    for t in $TARGETS; do
	if ! test -f "$REPORT1_DIR/$2/stage_$t.tmp"; then
	    continue
	fi

	failed_stage="$t"
    done
    echo "$failed_stage" | tee "$failed_stage_fn"
}

print_failed_pkg (){
    # $1 - pkgpath
    # $2 - breaks
    # $3 - stage
    # $4 - maintainer
    # $5 - pkgname
    if test -n "$2" && test "$2" != "Breaks"; then
	__href_beg="`printf '<a href=\"../%s/failed_packages.txt\" title=\"packages failed due to %s\">' $1 $1`"
	__href_end='</a>'
    else
	__href_beg=''
	__href_end=''
    fi

    short_pkgpath=$(echo $1 | cut -f1 -d:)
    printf "  <tr><td><a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%-27s</a></td> <td class=\"breaks\">${__href_beg}%7s${__href_end}</td> <td>%11s</td> <td align=\"right\">%27s</td>\n    <td align=\"right\">%-25s</td></tr>\n" "$5" "$3" "$short_pkgpath" "$short_pkgpath" "$2" "$3" "$4" "$5"
#    printf "  <tr><td><a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%-27s</a></td> <td class=\"breaks\">%7s</td> <td>%11s</td> <td align=\"right\">%27s</td>\n    <td align=\"right\">%-25s</td></tr>\n" "$1" "$3" "$1" "$1" "$2" "$3" "$4" "$5"
}

print_failed_deps_pkg (){
    # $1 - pkgpath
    # $2 - pkgname
    # $3 - maintainer
    # $4 - deppath
    # $5 - depname
    failed_stage=$(get_failed_stage "$4" "$5")
#    short_pkgpath=$(echo $1 | cut -f1 -d:)
#    printf "  <tr><td>%-27s</td> <td align=\"left\"><a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%s</a></td><td> %7s</td><td>\n  %-27s</td></tr>\n" "$1" "$4" "$failed_stage" "$4" "$4" "$3" "$2"
    printf "  <tr><td>%-26s</td> <td align=\"left\"><a href=\"../%s/stage_%s.html\" title=\"build log for %s\">%-26s</a></td><td> %s</td></tr>\n" "$1" "$2" "$failed_stage" "$4" "$4" "$3"
}

pkgpath2maintainer (){
    # $1 - pkgpath
    awk -v pkgpath="$1" '$1 == pkgpath {print $2; exit}' "$enriched_failed_fn"
}

pkgpath2pkgname (){
    # $1 - pkgpath
    awk -v pkgpath="$1" '$1 == pkgpath {print $3; exit}' "$enriched_failed_fn"
}

report_html (){
    if test "$PACKAGES_URL"; then
	url="<a href=\"$PACKAGES_URL\" title=\"binary packages\">binary packages</a>"
    else
	url='binary packages'
    fi

    cat <<EOF
<h1>pkgsrc bulk build results (distbb-$version)</h1>

<h2>$OS $OSVER</h2>

<!--  <p><a href="$REPORT_URL" title="Full report">$REPORT_URL</a></p> -->

EOF

    if test "$RESPONSIBLE"; then
	echo "<p>$RESPONSIBLE</p>"
    fi

    if test "$NOTES"; then
	echo '<h3><a name="notes"></a>Notes</h3>'
	printf '<p>'
	cat "$NOTES"
	printf '</p>'
    fi

    cat <<EOF

<h3><a name="summary"></a>Summary</h3>

<table><tr>  <td>Build started:</td><td align="right">$(right_align 38 "${build_start}")</td><td>&nbsp;</td></tr>
  <tr><td>Build ended:</td>  <td align="right">$(right_align 38 "${build_end}")</td><td>&nbsp;</td></tr>

  <tr><td>&nbsp;</td>                  <td>&nbsp;</td><td>&nbsp;</td></tr>
  <tr class="pkg-total"><td>Total packages</td>                  <td align="right">$(right_align 20 $packages_total)</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_total_fn)" title="List of total packages"> list</a></td></tr>
  <tr><td>Packages built previously</td>       <td align="right">$(right_align 20 $packages_built_prev_cnt)</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_built_prev_fn)" title="List of packages built previously"> list</a></td></tr>
  <tr class="pkg-built"><td>Packages built</td>                  <td align="right">$(right_align 20 $packages_built_cnt)</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_built_fn)" title="List of successfully built packages"> list</a></td></tr>
  <tr class="pkg-failed"><td>Packages failed</td>                 <td align="right">$(right_align 20 $packages_failed_cnt)</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_failed_fn)" title="List of failed packages"> list</a></td></tr>
  <tr class="pkg-faileddeps"><td>Packages failed due to them</td>     <td align="right">$(right_align 20 $packages_failed_deps_cnt)</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_failed_deps_fn)" title="List of packages failed due to their dependancies"> list</a></td></tr>
EOF

    if  test "$packages_failed_scan_cnt" -gt 0 ||
	test -s "$build_src_summary_log_fn"
    then
	cat <<EOF
  <tr class="pkg-failed"><td>Packages failed (pkg_src_summary/scanning) </td>   <td align="right">$(right_align 6 $packages_failed_scan_cnt)</td><td>&nbsp;&nbsp;&nbsp;<a href="$(basename $packages_failed_scan_fn)" title="List of packages failed while building pkg_src_summary"> list</a></td> <td>&nbsp;&nbsp;<a href="$(basename $build_src_summary_log_fn)" title="pkg_src_summary logs">logs</a></td></tr>
EOF
    fi

    cat <<EOF
  <tr><td>Packages in pkg_summary</td>         <td align="right">$(right_align 20 $packages_in_summary)</td></tr>
</table>
<p>Packages not listed here resulted in a $url.<br>
Results of failed packages are available below.<br>
Progress messages are <a href="$(basename $progress_fn)" title="Progress messages">here</a>.<br> <!-- REMOVE ME -->
pkg_src_summary is <a href="$(basename $pkg_src_summary_fn)" title="pkgsrc source packages summary">here</a>.<br> <!-- REMOVE ME -->
pkg_summary vs. pkg_src_summary <a href="$(basename $summary_cmp_fn)" title="binary packages agains pkgsrc tree">comparison</a>.<br> <!-- REMOVE ME -->
EOF

    cat <<EOF
</p>
<p>Jump to:
<ul>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#failures per maintainer">Failures per maintainer</a></li>
    <li><a href="#failed">Failed packages</a></li>
    <li><a href="#failed depends">Failed due to dependencies</a></li>
</ul>

EOF

    # failures per maintainer
    cat <<EOF

<h3><a name="failures per maintainer"></a>Failures per maintainer</h3>

EOF
    printf '<table width="30%%">'
    printf '<tr><td>%-36s</td> <td align="right">%4s</td></tr>\n' '<b>Maintainer</b>' '<b>Breaks</b>'
    echo ''

    cat "$enriched_failed_fn" |
    while read pkgpath maintainer pkgname; do
	case "$(get_failed_stage $pkgpath $pkgname)" in
	    dbb_canbebuilt|dbb_excluded)
		continue;;
	esac

	echo "$maintainer $pkgpath"
	awk -v m=$maintainer '
	   { print m, $1}' "$REPORT1_DIR/$pkgname/failed_packages.txt"
    done | env LC_ALL=C sort -u |
    awk '{++count [$1]}
    END {for (m in count) print m, count [m] }' |
    sort -k2,2rn |
    head -n "$OFFENDERS_CNT" |
    awk '{
	printf "<tr><td>%-27s</td> <td align=\"right\">%4d</td></tr>\n", $1, $2
    }'

    printf '</table>\n'

    # failed packages
    cat <<EOF

<h3><a name="failed"></a>Failed packages</h3>

EOF
    printf '%s' '<table width="100%">'
    print_failed_pkg "Package" "Breaks" "Stage" "Maintainer" "" |
    sed -e 's,<a[^<>]*>,,' \
	-e 's,</a[^<>]*>,,' \
	-e 's,class="[^"]*",,g' \
	-e 's,[A-Z][a-z ]*,<b>&</b>,g'

    cat "$enriched_failed_fn" |
    while read pkgpath maintainer pkgname; do
	breaks=$(count_lines "$REPORT1_DIR/$pkgname/failed_packages.txt")
	failed_stage=$(get_failed_stage "$pkgpath" "$pkgname")
	echo "$pkgpath $breaks $failed_stage $maintainer $pkgname"
    done |
    sort -k2,2nr -k1,1 |
    while read pkgpath breaks failed_stage maintainer pkgname; do
	if test "$breaks" -eq 0; then
	    breaks=''
	fi
	print_failed_pkg "$pkgpath"  "$breaks" "$failed_stage" "$maintainer" "$pkgname"
    done
    printf '%s\n' "</table>"

    # failed dependencies
    echo '<h3><a name="failed depends"></a>Failed due to dependencies</h3>'

    printf '%s' '<table width="100%">'

    echo ''
    print_failed_deps_pkg 'Package' '' 'Maintainer' 'Failed dependencies' |
    sed -e 's,<a[^<>]*>,,' \
	-e 's,</a[^<>]*>,,' \
	-e 's,[A-Z][a-z ]*,<b>&</b>,g'
    echo ''

    while read pkgpath maintainer pkgname; do
	fn="$REPORT1_DIR/$pkgname/failed_because.txt"
	cnt=$(count_lines "$fn")
	deppath=$(head -1 "$fn")
	depname=$(pkgpath2pkgname "$deppath")
	depX=$(awk -v cnt="$cnt" -v failed_deps_cnt="$MAX_FAILED_DEPS_CNT" \
	    'NR > cnt-failed_deps_cnt+1 && NR > 1' "$fn")
	print_failed_deps_pkg \
	    "$pkgpath" "$pkgname" "$maintainer" "$deppath" "$depname"
	for deppath in $depX; do
	    maintainer=$(pkgpath2maintainer "$deppath")
	    depname=$(pkgpath2pkgname "$deppath")
	    print_failed_deps_pkg '' '' "$maintainer" "$deppath" "$depname"
	done
    done < "$enriched_failed_deps_fn"
    printf "%s\n" "</table>"
}

packages_failed_scan_cnt=$(count_lines "$packages_failed_scan_fn")
packages_failed_deps_cnt=$(count_lines "$packages_failed_deps_fn.raw")
packages_failed_cnt=$(count_lines "$packages_failed_fn.raw")
packages_built_cnt=$(count_lines "$packages_built_fn.raw")
packages_built_prev_cnt=$(count_lines "$packages_built_prev_fn.raw")
packages_total=$(($packages_built_cnt+$packages_built_prev_cnt))
packages_in_summary=$(awk '{cnt += ($0 ~ /^PKGNAME=/)} END {print cnt}' "$PKG_SUMMARY")

enriched_failed_fn="$tmpdir/enriched_failed.tmp"
enrich_pkgpath "MAINTAINER PKGNAME" \
    "$packages_failed_fn.raw" > "$enriched_failed_fn"

enriched_failed_deps_fn="$tmpdir/enriched_failed_deps.tmp"
enrich_pkgpath "MAINTAINER PKGNAME" \
    "$packages_failed_deps_fn.raw" > "$enriched_failed_deps_fn"

##

verbose_print "  enriching META/packages_*.txt..."

runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_built_prev_fn.raw '|' \
    sort > $packages_built_prev_fn
runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_built_fn.raw '|' \
    sort > $packages_built_fn
runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_failed_fn.raw '|' \
    sort > $packages_failed_fn
runpipe0 \
    enrich_pkgpath 'PKGNAME MAINTAINER' $packages_failed_deps_fn.raw '|' \
    sort > $packages_failed_deps_fn

verbose_print "done\n"

##

verbose_print "  creating META/packages_total.txt..."

env LC_ALL=C sort -u "$packages_built_fn" "$packages_built_prev_fn" \
    > "$packages_total_fn"

verbose_print "done\n"

##
html_header (){
    cat <<EOF
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">

<html> <head> <title>$os</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<style type="text/css">
<!--

tr {
	Vertical-Align: top;
}

td {
	Vertical-Align: top;
}

h1 {
	Font-Size: 3.5ex;
	Line-Height: 1em;
	Color: #000066;
}

h2 {
	Font-Size: 2.5ex;
	Line-Height: 1em;
	Color: #660000;
}

h3 {
	Font-Size: 2ex;
	Color: #660066;
}

.pkg-total {
	Color: blue;
}

.pkg-built {
	Color: green;
}

.pkg-failed {
	Color: red;
}

.pkg-faileddeps {
	Color: orange;
}

.breaks {
	Color: red;
}

-->
</style>
</head>

<body>

EOF
}

html_footer (){
    cat <<EOF
</body>
</html>
EOF
}

report_full_html (){
    html_header

    report_html

    html_footer
}

report_full_html > "$meta_dir/report.html"

report_html2txt (){
   awk '
   /Jump to:/, NF == 0 {
      next
   }
   /REMOVE ME/ {
      next
   }
   {
      gsub(/<!--|-->/, "")
      gsub(/<[^<>]*>/, "")
      gsub(/&[a-z]*;/, "")
   }
   /Summary/, /Failures per/ {
      if (NF > 0 && $NF ~ /^(list|logs)$/)
         gsub(/list|logs/, "")
      if (/Progress messages/)
         next
   }
   { print }
   ' "$@"
}

report_txt_fn="$meta_dir/report.txt"
report_html | report_html2txt > "$report_txt_fn"

### generate per file HTMLs
stage2html (){
    html_header

    pkgdir="$(echo $1 | sed 's,/[^/]*$,,')"
    pkgpath="$(echo $1 | sed 's,^.*/\([^/]*/[^/]*\)/[^/]*$,\1,')"
    stage="$(echo $1 | sed 's,^.*stage_\(.*\)[.].*$,\1,')"

    printf '<p>'
    for t in $TARGETS; do
	printf '&nbsp;'

	if test -f "$pkgdir/stage_$t.tmp"; then
	    if test "$t" = "$stage"; then
		printf "$stage"
	    else
		printf "<a href=\"stage_%s.html\" title=\"build log for %s\">%s</a>\n" "$t" "$pkgpath" "$t"
	    fi
	fi

	printf '&nbsp;'
    done
    printf '<br></p>\n'

    # log itself
    printf "<pre>"
    cat "$1"
    printf "</pre>"
    html_footer
}

find "$REPORT1_DIR" -name 'stage_*.tmp' |
while read stage_fn; do
    html_fn=${stage_fn%%.tmp}.html
    stage2html "$stage_fn" >"$html_fn"
done

verbose_print "done\n"
