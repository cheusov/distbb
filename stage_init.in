#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

######################################################################

set -e
. @@bindir@@/pipestatus

# usage: stage_init BUILD_ID
test $# -eq 1

# init
BUILD_ID="$1"
test -n "$build_start" # MUST be set in environment

packages="$pkgs_fn" # pkgs_fn - from distbb

DISTBB_CONF=${DISTBB_CONF:-@@sysconfdir@@/distbb.conf}
. "$DISTBB_CONF"
. @@libexecdir@@/common

if echo > "$MSCOMMONDIR/check"; then
    rm "$MSCOMMONDIR/check"
else
    cat <<EOF
$MSCOMMONDIR directory is not writable or doesn't exist.
EOF
    exit 1
fi

test -n "$BUILD_ID" -a -n "$REPORTS_DIR" # who knows...
rm -rf $REPORT1_DIR
mkdir -p -m 700 $tmpdir
cp "$ICON_FILE" "$REPORT1_DIR/distbb.ico"
cp "$CSS_FILE" "$REPORT1_DIR/distbb.css"

echo "$build_start" > $build_start_fn

# main
verbose_print "Preparations\n"

printf '' > $packages_failed_notavail_fn.tmp
printf '' > $packages_failed_scan_fn
printf '' > $packages_failed_deps_fn
printf '' > $packages_failed_fn.tmp
printf '' > $packages_built_prev_fn
printf '' > $packages_built_fn.tmp

printf '' > $progress_fn

######################################################################
### unpacking bootstrap
verbose_print "  removing PREFIX and unpacking bootstrap..."
if test -n "$MASTER_MODE"; then
    for s in $SLAVES; do
	eval $TRANSPORT "$s" @@libexecdir@@/wrapper $RMDIRS_CMD
	eval $TRANSPORT "$s" @@libexecdir@@/wrapper $EXTRACT_BOOTSTRAP_CMD
    done
else
    eval @@libexecdir@@/wrapper $RMDIRS_CMD
    eval @@libexecdir@@/wrapper $EXTRACT_BOOTSTRAP_CMD
fi
verbose_print "done\n"

######################################################################
### initial packages
verbose_print "  initial packages..."

cleanup_package_list (){
    awk '
    {
       sub(/#.*$/, "")
    }
    NF > 0 {
       print $1
    }' "$packages"
}

if test "$packages"; then
    # remove comments and empty lines
    cleanup_package_list > $packages_fn.tmp
else
    if test -n "$MASTER_MODE" -a -n "$TRANSPORT" -a -n "$SLAVES"; then
	slave1="$(echo $SLAVES | sed 's, .*$,,')"
	environ="BMAKE=$BMAKE PKGSRCDIR=$PKGSRCDIR CKSUM=$CKSUM"
	eval $TRANSPORT $slave1 "env $environ @@libexecdir@@/wrapper $LIST_ALL_PKGS_CMD" > $packages_fn.tmp
    else
	eval @@libexecdir@@/wrapper $LIST_ALL_PKGS_CMD > $packages_fn.tmp
    fi
fi

# add extra packages to the list of packages requested by user
for p in $EXTRA_DEPS; do
    echo $p >> $packages_fn.tmp
done

sort_uniq_inplace $packages_fn.tmp

verbose_print "done\n"

######################################################################
### updating PKG_SUMMARY

refreshed_summary_fn=$tmpdir/refreshed_summary.tmp
if test -z "$skip_updating_summary"; then
    verbose_print "  updating pkg_summary..."
    eval @@libexecdir@@/wrapper $PKG_UPDATE_SUMMARY_CMD $PKG_SUMMARY $PACKAGES/All
    verbose_print "done\n"
fi

pkg_refresh_summary $PKG_SUMMARY >$refreshed_summary_fn

######################################################################
### updating PKG_SRC_SUMMARY

if test -z "$skip_updating_src_summary"; then
    if test -z "$MASTER_MODE"; then
	unset PSS_SLAVES || true
    fi

    verbose_print "  updating pkg_src_summary..."
    set +e # workaround for buggy Korn Shell
           # ('set -e' + if + eval + false)
    if ! eval "@@libexecdir@@/wrapper $PKG_UPDATE_SRC_SUMMARY_CMD \
	< $packages_fn.tmp 2> $build_src_summary_log_fn"
    then
	cat $build_src_summary_log_fn 1>&2
	exit 1
    fi
    set -e
    verbose_print "done\n"
fi

pkg_assignments2pkgpath "$PKG_SRC_SUMMARY" > "$pkg_src_summary_fn.tmp"
pkg_summary2bb_pkgs "$pkg_src_summary_fn.tmp" > "$pkg_src_summary_fn"
rm "$pkg_src_summary_fn.tmp"

######################################################################
### packages for which pkg_src_summary failed.
verbose_print "  is there packages for which pkg_src_summary failed?..."

awk -v packages_fn=$packages_fn \
    -v packages_failed_scan_fn=$packages_failed_scan_fn '
FILENAME == (packages_fn ".tmp") {
   if (NF == 1) pkgs [$1] = 1
   next
}
/^PKGPATH=/ {
   gsub(/ +$/, "")
   pkgpath = substr($0, 9)
   short_pkgpath = pkgpath
   sub(/:.*$/, "", short_pkgpath)
   if ((pkgpath in pkgs) || (short_pkgpath in pkgs)){
      print pkgpath > packages_fn
      printed [pkgpath] = printed [short_pkgpath] = 1
   }
}
END {
   for (pkgpath in pkgs){
      if (! (pkgpath in printed))
         print pkgpath > packages_failed_scan_fn
   }
}' $packages_fn.tmp $pkg_src_summary_fn
#rm $packages_fn.tmp
touch $packages_fn
verbose_print "done\n"

######################################################################
### comparison binaries against pkgsrc tree
verbose_print "  pkg_summary vs. pkg_src_summary comparison..."
eval @@libexecdir@@/wrapper \
    $PKG_CMP_SUMMARY_CMD $refreshed_summary_fn $pkg_src_summary_fn \
    > $summary_cmp_fn
verbose_print "done\n"

if grep '^>' $summary_cmp_fn > /dev/null; then
    cat >> "$build_src_summary_log_fn" <<'EOF'
 ------------------
Versions of some packages go backward

EOF
    grep '^>' $summary_cmp_fn >> "$build_src_summary_log_fn"
fi

######################################################################
### extracting DEPENDS and BUILD_DEPENDS

# store DEPENDS and BUILD_DEPENDS dependencies in
#  "$all_deps_fn" file
# input: "$PKG_SRC_SUMMARY file and $EXTRA_DEPS packages.
# output format: <DEPENDANCY_PKGPATH> <PKGPATH>

verbose_print "  build graph from pkg_src_summary file..."

if ! pkg_summary2build_graph "$pkg_src_summary_fn" \
    1> "$all_deps_fn" \
    2> "$build_deps_graph_log_fn"
then
    cat "$build_deps_graph_log_fn" 1>&2
fi

verbose_print "done\n"

######################################################################
### extra dependencies (pkgtools/digest, sysutils/checkperms)
verbose_print "  extra dependencies..."

# extra dependancies from $EXTRA_DEPS
# EXTRA_DEPS
awk -v extra_deps="$EXTRA_DEPS" '
BEGIN {
    cnt = split(extra_deps, _deps, / /)
    for (i in _deps){
	deps [_deps [i]] = 1
    }
    for (i=2; i <= cnt; ++i){
	print _deps [i-1], _deps [i]
    }
}
$1 ~ /^PKGPATH=/ {
    $1 = substr($1, 9)
    print $1
    if (!($1 in deps))
	print _deps [cnt], $1
}
' $pkg_src_summary_fn >> "$all_deps_fn"

sort_uniq_inplace "$all_deps_fn"

verbose_print "done\n"

######################################################################
### initial packages with dependancies

# remove comments and empty lines
if test "$packages"; then
    verbose_print "  initial packages with their dependencies..."

    runpipe0 \
	pkg_subgraph_deps -r -f "$packages_fn" "$all_deps_fn" '|' \
	sort_uniq > "$reqd_deps_fn"

    verbose_print "done\n"
else
    cp "$all_deps_fn" "$reqd_deps_fn"
fi

######################################################################
### packages to rebuild

verbose_print "  packages to rebuild..."

changed_pkgs_fn=$tmpdir/changed.tmp
awk '$1 ~ /^[^=-]$/ {print $2}' "$summary_cmp_fn" > "$changed_pkgs_fn"

pkg_subgraph_deps -f "$changed_pkgs_fn" "$reqd_deps_fn" \
    > "$rebuild_fn"

verbose_print "done\n"

######################################################################
### list of already built packages

verbose_print "  packages built previously (no need to rebuild)..."

runpipe0 \
    pkg_subgraph_deps -v -f "$changed_pkgs_fn" "$reqd_deps_fn" '|' \
    awk 'NF == 2 {$0 = $1 "\n" $2} {print}' '|' \
    sort_uniq > "$packages_built_prev_fn.tmp"

verbose_print "done\n"

######################################################################
### list of already built packages

verbose_print "  copying auxiliary files..."

cp "$pkg_src_summary_fn" "$aux_pkg_src_summary_fn"
cp "$reqd_deps_fn"       "$aux_reqd_deps_fn"

verbose_print "done\n"

######################################################################
