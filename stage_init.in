#!/bin/sh

# Copyright (c) 2007-2008 Aleksey Cheusov <vle@gmx.net>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

######################################################################

set -e
. @@bindir@@/pipestatus

# usage: stage_init BUILD_ID UPDATE_SRC_SUMMARY BUILD_START
test $# -eq 3

# init
BUILD_ID="$1"
skip_updating_src_summary="$2"
build_start="$3"

packages="$pkgs_fn" # pkgs_fn - from distbb

. @@sysconfdir@@/distbb.conf

REPORT1_DIR=$REPORTS_DIR/$BUILD_ID
test -n "$REPORT1_DIR" # who knows...
rm -rf $REPORT1_DIR
. @@libexecdir@@/common

echo "$build_start" > $build_start_fn

# main
verbose_print "Preparations\n"

printf '' > $packages_failed_scan_fn
printf '' > $packages_failed_deps_fn
printf '' > $packages_failed_fn.raw
printf '' > $packages_built_prev_fn
printf '' > $packages_built_fn.raw

printf '' > $progress_fn

######################################################################
### unpacking bootstrap
verbose_print "  unpacking bootstrap to PREFIX..."
if test "$MASTER_MODE"; then
    for s in $SLAVES; do
	eval $TRANSPORT "$s" $RMDIRS_CMD
	eval $TRANSPORT "$s" $EXTRACT_BOOTSTRAP_CMD
    done
else
    eval $RMDIRS_CMD
    eval $EXTRACT_BOOTSTRAP_CMD
fi
verbose_print "done\n"

######################################################################
### initial packages
verbose_print "  initial packages..."

cleanup_package_list (){
    awk '
    {
       sub(/#.*$/, "")
    }
    NF > 0 {
       print $1
    }' "$packages"
}

if test "$packages"; then
    # remove comments and empty lines
    cleanup_package_list > $packages_fn.tmp
else
    if test -n "$TRANSPORT" -a -n "$SLAVES"; then
	slave1="$(echo $SLAVES | sed 's, .*$,,')"
	environ="BMAKE=$BMAKE PKGSRCDIR=$PKGSRCDIR CKSUM=$CKSUM"
	eval $TRANSPORT $slave1 "env $environ $LIST_ALL_PKGS_CMD" > $packages_fn.tmp
    else
	eval $LIST_ALL_PKGS_CMD > $packages_fn.tmp
    fi
fi

# add extra packages to the list of packages requested by user
for p in $EXTRA_DEPS; do
    echo $p >> $packages_fn.tmp
done

env LC_ALL=C sort -u $packages_fn.tmp > $packages_fn.tmp2
mv $packages_fn.tmp2 $packages_fn.tmp

verbose_print "done\n"

######################################################################
### updating PKG_SUMMARY

refreshed_summary_fn=$tmpdir/refreshed_summary.tmp
verbose_print "  updating pkg_summary..."
eval $PKG_UPDATE_SUMMARY_CMD $PKG_SUMMARY $PACKAGES/All
pkg_refresh_summary $PKG_SUMMARY >$refreshed_summary_fn
verbose_print "done\n"

######################################################################
### updating PKG_SRC_SUMMARY
if test -z "$skip_updating_src_summary"; then
    verbose_print "  Updating pkg_src_summary..."
    eval "$PKG_UPDATE_SRC_SUMMARY_CMD \
	< $packages_fn.tmp 2> $build_src_summary_log_fn"
    verbose_print "done\n"
fi

cp "$PKG_SRC_SUMMARY" "$pkg_src_summary_fn"

######################################################################
### comparison binaries against pkgsrc tree
verbose_print "  is there packages for which pkg_src_summary failed?..."

awk -v packages_fn=$packages_fn \
    -v packages_failed_scan_fn=$packages_failed_scan_fn '
FILENAME == (packages_fn ".tmp") {
   if (NF == 1) pkgs [$0] = 1
   next
}
/^PKGPATH=/ {
   gsub(/ +$/, "")
   pkgpath = substr($0, 9)
   if (pkgpath in pkgs){
      print pkgpath > packages_fn
      delete pkgs [pkgpath]
   }
}
END {
   for (pkgpath in pkgs){
      print pkgpath > packages_failed_scan_fn
   }
}' $packages_fn.tmp $PKG_SRC_SUMMARY
#rm $packages_fn.tmp
touch $packages_fn
verbose_print "done\n"

######################################################################
### comparison binaries against pkgsrc tree
verbose_print "  pkg_summary vs. pkg_src_summary comparison..."
pkg_cmp_summary -p $refreshed_summary_fn $PKG_SRC_SUMMARY > $summary_cmp_fn
verbose_print "done\n"

######################################################################
### extracting DEPENDS and BUILDS_DEPENDS

# store DEPENDS and BUILD_DEPENDS dependcies in
#  "$deps_fn", "$bdeps_fn" and $extradeps_fn files
# input: "$PKG_SRC_SUMMARY file and $EXTRA_DEPS packages.
# output format: <PKGNAME> <DEPENDANCY_PKGPATH> <PKGPATH>

verbose_print "  dependencies from pkg_src_summary file..."

deps_fn=$tmpdir/deps.tmp

extract_depends (){
    awk -v deps_fn="$deps_fn" '
/^PKGPATH=/ {
   pkgpath = substr($0, 9)
   next
}

/^(BUILD_)?DEPENDS=/ {
   sub(/^[^=]*=/, "")
   gsub(/[^ \t]+:[.][.]\/[.][.]\//, "")

   for (i=1; i <= NF; ++i){
      deps [$i] = 1
   }

   next
}

NF == 0 {
   for (i in deps){
      print i, pkgpath > deps_fn
   }
   delete deps
   pkgpath = ""
}
' "$PKG_SRC_SUMMARY"
}

extract_depends

verbose_print "done\n"

verbose_print "  extra dependencies..."

# extra dependancies from $EXTRA_DEPS
for d in dummy $EXTRA_DEPS; do
    # EXTRA_DEPS
    awk -v d=$d -F= -v extra_deps="$EXTRA_DEPS" '
    BEGIN {
	split(extra_deps, _deps, / /)
	for (i in _deps){
	    deps [_deps [i]] = 1
	}
    }
    $1 == "PKGPATH" && !($2 in deps) {
	print d, $2
    }
    ' $PKG_SRC_SUMMARY >> $deps_fn.tmp

    test dummy = $d && continue

    # EXTRA_DEPS_CMD
    deps="`cd $PKGSRCDIR/$d && eval $EXTRA_DEPS_CMD | sed 's,[^ ]*:[.][.]/[.][.]/,,g'`"
    for dep in $deps; do
	if echo $EXTRA_DEPS | grep $dep > /dev/null; then
	    echo $dep $d >> $deps_fn.tmp
	fi
    done
done

runpipe0 \
    env LC_ALL=C sort $deps_fn $deps_fn.tmp '|' \
    env LC_ALL=C uniq > $deps_fn.tmp2

mv $deps_fn.tmp2 $deps_fn
rm $deps_fn.tmp

verbose_print "done\n"

######################################################################
### input: graph as a list of arcs
### output: transitive close of this graph
transitive_closure (){
    awk '
# AWK badly suits for this task :-(

BEGIN {
   SUBSEP = " "
}

{
   arc [$1, $2] = 1

   outgoing [$1] = outgoing [$1] " " $2
   incoming [$2] = incoming [$2] " " $1

   nodes [$1] = 1
   nodes [$2] = 1
}

END {
   for (k in nodes){
      cnt_i = split(incoming [k], arr_i)
      for (ii = 1; ii <= cnt_i; ++ii){
         i = arr_i [ii]

         cnt_j = split(outgoing [k], arr_j)
         for (jj = 1; jj <= cnt_j; ++jj){
            j = arr_j [jj]
            if (! ((i SUBSEP j) in arc)){
               arc [i, j] = 1
               incoming [j] = incoming [j] " " i
               outgoing [i] = outgoing [i] " " j
            }
         }
      }
   }

   for (idx in arc){
      print idx
   }
}
' "$@"
}

verbose_print "  transitive closure of the dependancy graph..."
trans_clos_fn=$tmpdir/trans_closure.tmp
transitive_closure $deps_fn > $trans_clos_fn
verbose_print "done\n"

######################################################################
### initial packages with dependancies

# print packages found in "$packages"
# and packages they depend on
with_dependancies (){
    awk -v pkgs="$1" '
BEGIN {
   while (getline < pkgs){
      hash [$1] = 1
      print $1
   }
}

($1 != "dummy") && ($2 in hash) {
   print $1
}
' "$2"
}

# remove comments and empty lines
if test "$packages"; then
    verbose_print "  initial packages with dependancies..."

    runpipe0 \
	with_dependancies "$packages_fn" "$trans_clos_fn" '|' \
	sort -u > $packages_with_deps_fn

    verbose_print "done\n"
else
    cp $packages_fn $packages_with_deps_fn
fi

######################################################################
### final transitive closure
verbose_print "  building reduced transitive closure with requested packages only..."

trans_closure_final (){
    awk -v pkgs="$1" '
BEGIN {
   while (getline < pkgs){
      hash [$1] = 1
   }
}

$2 in hash {
   print $0
}
' "$2"
}

trans_clos_final_fn=$tmpdir/trans_closure_final.tmp
trans_closure_final \
    "$packages_with_deps_fn" \
    "$trans_clos_fn" > "$trans_clos_final_fn"

trans_clos_full_fn=$tmpdir/trans_closure_full.tmp
mv "$trans_clos_fn" "$trans_clos_full_fn"
mv "$trans_clos_final_fn" "$trans_clos_fn"

verbose_print "done\n"

######################################################################
### direct packages that need to be rebuilt
verbose_print "  direct packages to be built..."

rebuild1_fn=$tmpdir/rebuild1.tmp

awk -v pkgs="$packages_with_deps_fn" '
BEGIN {
   while (getline < pkgs){
      hash [$1] = 1
   }
}

($1 != "=") && ($1 != "-") && ($2 in hash) {print $2}
' "$summary_cmp_fn" > $rebuild1_fn

verbose_print "done\n"

######################################################################
### direct packages that need to be rebuilt
verbose_print "  all packages to be built..."

all_packages_to_be_build () {
awk -v pkgs="$rebuild1_fn" '
BEGIN {
   while (getline < pkgs){
      hash [$1] = 1
      print $1
   }
}

($1 in hash) {
   print $2
}
' "$trans_clos_fn"
}

all_packages_to_be_build2 () {
awk -v pkgs="$rebuild_fn" '
BEGIN {
   while (getline < pkgs){
      hash [$1] = 1
   }
}

($1 in hash) {
   print $1, $2
}
' "$trans_clos_fn"
}

runpipe0 \
    all_packages_to_be_build '|' \
    sort -u > $rebuild_fn
runpipe0 \
    all_packages_to_be_build2 '|' \
    sort -u > $trans_clos_rebuild_fn

verbose_print "done\n"

######################################################################
### graph of packages for paexec
gen_queue (){
    runawk -v deps_fn="$deps_fn" -e '
#use "xgetline.awk"

BEGIN {
   while (xgetline0(deps_fn)){
      deps [$1, $2] = 0
   }
}

NF == 2 {
   if ($1 == "dummy")
      print $2
   else if (($1 SUBSEP $2) in deps)
      print $1, $2

   hash [$1] = 0
   hash [$2] = 0
   next
}
NF == 1 && !($1 in hash) {
   print $1
   next
}
' "$@"
}

verbose_print "  initial queue..."

gen_queue $trans_clos_rebuild_fn $rebuild1_fn > $queue_fn

verbose_print "done\n"

######################################################################
### list of already built packages

verbose_print "  packages built previously (no need to rebuild)..."

generate_built_prev (){
    awk '
{ cnt [$1] += 1 }
END {
   for (pkg in cnt) {
      if (cnt [pkg] == 1) print pkg
   }
}
'  "$packages_with_deps_fn" "$rebuild_fn"
}

runpipe0 \
    generate_built_prev '|' \
    env LC_ALL=C sort > "$packages_built_prev_fn.raw"

verbose_print "done\n"

######################################################################
