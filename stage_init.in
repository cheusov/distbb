#!/bin/sh

# Copyright (c) 2008-2011 Aleksey Cheusov <vle@gmx.net>
# All rights reserved.
#
# See LICENSE file

######################################################################

set -e
. @bindir@/pipestatus

export LC_ALL=C

# usage: stage_init BUILD_ID
test $# -eq 1

# init
BUILD_ID="$1"
test -n "$build_start" # MUST be set in environment

packages="$pkgs_fn" # pkgs_fn - from distbb

DISTBB_CONF=${DISTBB_CONF:-@sysconfdir@/distbb.conf}
. "$DISTBB_CONF"
. @libexecdir@/common

mkdir -p "$MSCOMMONDIR"

if touch "$MSCOMMONDIR/check"; then
    rm "$MSCOMMONDIR/check"
else
    cat <<EOF
$MSCOMMONDIR directory is not writable or doesn't exist.
EOF
    exit 1
fi

test -n "$BUILD_ID" -a -n "$REPORTS_DIR" # who knows...
rm -rf $REPORT1_DIR
mkdir -p -m 700 $tmpdir
cp "$ICON_FILE" "$REPORT1_DIR/distbb.ico"
cp "$CSS_FILE" "$REPORT1_DIR/distbb.css"

echo "$build_start" > $build_start_fn

# main
verbose_print "Preparations\n"

printf '' > $packages_failed_notavail_fn.tmp
printf '' > $packages_failed_scan_fn
printf '' > $packages_failed_deps_fn
printf '' > $packages_failed_fn.tmp
printf '' > $packages_built_prev_fn

printf '' > $progress_fn

######################################################################
### unpacking bootstrap
verbose_print "  removing PREFIX and unpacking bootstrap..."
if test -n "$MASTER_MODE"; then
    for s in $SLAVES; do
	eval $TRANSPORT "$s" @libexecdir@/wrapper $RMDIRS_CMD
	eval $TRANSPORT "$s" @libexecdir@/wrapper $EXTRACT_BOOTSTRAP_CMD
    done
else
    eval @libexecdir@/wrapper $RMDIRS_CMD
    eval @libexecdir@/wrapper $EXTRACT_BOOTSTRAP_CMD
fi
verbose_print "done\n"

######################################################################
### initial packages
verbose_print "  initial packages..."

cleanup_package_list (){
    awk '
    {
       sub(/#.*$/, "")
    }
    NF > 0 {
       print $1
    }' "$packages"
}

if test "$packages"; then
    # remove comments and empty lines
    cleanup_package_list > $packages_fn.tmp
else
    if test -n "$MASTER_MODE" -a -n "$TRANSPORT" -a -n "$SLAVES"; then
	slave1="$(echo $SLAVES | sed 's, .*$,,')"
	environ="BMAKE=$BMAKE PKGSRCDIR=$PKGSRCDIR CKSUM=$CKSUM"
	eval $TRANSPORT $slave1 "env $environ @libexecdir@/wrapper $LIST_ALL_PKGS_CMD" > $packages_fn.tmp
    else
	eval @libexecdir@/wrapper $LIST_ALL_PKGS_CMD > $packages_fn.tmp
    fi
fi

# add extra packages to the list of packages requested by user
for p in $EXTRA_DEPS; do
    echo $p >> $packages_fn.tmp
done

sort_uniq_inplace $packages_fn.tmp

verbose_print "done\n"

######################################################################
### updating PKG_ALL_SUMMARY

if test -z "$skip_updating_summary"; then
    verbose_print "  updating pkg_all_summary..."
    eval @libexecdir@/wrapper $PKG_UPDATE_ALL_SUMMARY_CMD "$PKG_ALL_SUMMARY" "$PACKAGES/All"
    verbose_print "done\n"
fi

######################################################################
### updating PKG_SRC_SUMMARY

printf '' >> "$build_src_summary_log_fn"

if test -z "$skip_updating_src_summary"; then
    if test -z "$MASTER_MODE"; then
	unset PSS_SLAVES || true
    fi

    verbose_print "  updating pkg_src_summary..."
    set +e # workaround for buggy Korn Shell
           # ('set -e' + if + eval + false)
    if ! eval "@libexecdir@/wrapper $PKG_UPDATE_SRC_SUMMARY_CMD \
	< $packages_fn.tmp 2> $build_src_summary_log_fn"
    then
	cat "$build_src_summary_log_fn" 1>&2
	exit 1
    fi
    set -e
    verbose_print "done\n"
fi

pkg_assignments2pkgpath "$PKG_SRC_SUMMARY" > "$pkg_src_summary_fn.tmp"
pkg_summary2bb_pkgs "$pkg_src_summary_fn.tmp" > "$pkg_src_summary_fn"
rm "$pkg_src_summary_fn.tmp"

######################################################################
### packages for which pkg_src_summary failed.
verbose_print "  is there packages for which pkg_src_summary failed?..."

awk -v packages_fn=$packages_fn \
    -v packages_failed_scan_fn=$packages_failed_scan_fn '
FILENAME == (packages_fn ".tmp") {
   if (NF == 1) pkgs [$1] = 1
   next
}
/^PKGPATH=/ {
   gsub(/ +$/, "")
   pkgpath = substr($0, 9)
   short_pkgpath = pkgpath
   sub(/:.*$/, "", short_pkgpath)
   if ((pkgpath in pkgs) || (short_pkgpath in pkgs)){
      print pkgpath > packages_fn
      printed [pkgpath] = printed [short_pkgpath] = 1
   }
}
END {
   for (pkgpath in pkgs){
      if (! (pkgpath in printed))
         print pkgpath > packages_failed_scan_fn
   }
}' $packages_fn.tmp $pkg_src_summary_fn
#rm $packages_fn.tmp
touch $packages_fn

verbose_print "done\n"

######################################################################
### dependency graph of packages to rebuild
verbose_print "  dependency graph of packages to rebuild..."

awk '
/^PKGNAME/ {pkgbase = substr($0, 9); sub(/-[^-]*$/, "", pkgbase)}
/^PKGPATH/ {pkgpath = substr($0, 9); sub(/:.*$/, "", pkgpath)}
NF == 0 {print pkgpath "," pkgbase}
' "$pkg_src_summary_fn" > "$tmpdir/src_PABA.tmp"

sed -n 's/^PKGPATH=//p' "$pkg_src_summary_fn" |
sort -u > "$tmpdir/all_src_pkgpaths"

pkg_summary2deps -Apnrsal -P $tmpdir/all_src_pkgpaths \
    "$pkg_src_summary_fn" "$PKG_ALL_SUMMARY" \
    > "$tmpdir/all_deps.tmp" 2>/dev/null

runawk -f xgetline.awk -f psu_funcs.awk \
       -v pkg_bin_summary_fn="$PKG_ALL_SUMMARY" \
       -v pkg_src_summary_fn="$pkg_src_summary_fn" \
       -v tmpdir="$tmpdir" \
-e '
function read_summary (fn, hash){
   while (xgetline0(fn)){
      if ($0 ~ /^PKGPATH=/)
         pkgpath = substr($0, 9)
      else if ($0 ~ /^PKGNAME=/)
         pkgname = substr($0, 9)
      else if (NF == 0){
         hash [pkgpath ";" pkgname] = 0
         pkgname = pkgpath = ""
      }
   }
   close(fn)
}

BEGIN {
   read_summary(pkg_src_summary_fn, src_PAeNA)
   read_summary(pkg_bin_summary_fn, bin_PANA)
}

function print_dep (dep, pkg){
   if (pkg != ""){
      print dep, pkg
      already_printer [dep] = already_printer [pkg] = 0
   }else if (! (dep in already_printer)){
      print dep
      already_printer [dep] = 0
   }
}

function PAeNA2PANA (pkg){
   sub(/:[^;]*/, "", pkg)
   return pkg
}

NF == 2 {
   cnt = split($1, arr, /[|]/)
   older1 = newer1 = ""
   for (i=1; i <= cnt; ++i){
      dep = arr [i]

      if (dep in bin_PANA){
         if (older1 in src_PAeNA)
            continue

         if (!older1 || (dep in src_PAeNA) ||
            pkgname_gt_pkgname(dep, older1))
         {
            older1 = dep
         }
      }else{
         newer1 = dep
         print_dep(newer1)
      }
   }

   if (($2 in src_PAeNA) && !(PAeNA2PANA($2) in bin_PANA))
      rebuild_PAeNA [$2] = 1

   if (!older1 && (newer1 in src_PAeNA))
      rebuild_PAeNA [newer1] = 2

   if (older1)
      print_dep(older1, $2)
   else if (newer1)
      print_dep(newer1, $2)
   else
      abort("Neither older1 nor newer1 are set")

   next
}
NF == 1 {
   if (($1 in src_PAeNA) && !(PAeNA2PANA($1) in bin_PANA))
      rebuild_PAeNA [$1] = 3
}
END {
   for (i in rebuild_PAeNA){
      print_dep(i)
      print i > (tmpdir "/rebuild_PAeNA.tmp")
   }
   for (i in src_PAeNA){
      print i > (tmpdir "/src_PAeNA.tmp")
   }
}
' "$tmpdir/all_deps.tmp" > "$tmpdir/reqd_deps_pre.tmp"

printf '' >> "$tmpdir/reqd_deps_pre.tmp"
printf '' >> "$tmpdir/src_PAeNA.tmp"
printf '' >> "$tmpdir/rebuild_PAeNA.tmp"

pkg_subgraph_deps -r -f "$tmpdir/src_PAeNA.tmp" "$tmpdir/reqd_deps_pre.tmp" \
	> "$tmpdir/reqd_deps_pre.tmp_"
mv "$tmpdir/reqd_deps_pre.tmp_" "$tmpdir/reqd_deps_pre.tmp"

sed 's/[^ ]*;//g' "$tmpdir/reqd_deps_pre.tmp" > "$reqd_deps_fn"

pkg_subgraph_deps -f "$tmpdir/rebuild_PAeNA.tmp" \
    "$tmpdir/reqd_deps_pre.tmp" | sed 's/;[^ ]*//g'  > "$tmpdir/rebuild.tmp"

printf '' > "$errors_fn"
printf '' > "$summary_cmp_fn"

# rebuilt previously
changed_pkgs_fn=$tmpdir/changed.tmp
awk 'NF == 2 {print $1 "\n" $2; next} {print}' "$rebuild_fn" |
sort -u > "$changed_pkgs_fn"

sort "$changed_pkgs_fn" "$changed_pkgs_fn" "$tmpdir/all_src_pkgpaths" |
uniq -c |
awk '$1 == 1 {print $2}' > "$packages_built_prev_fn.tmp"

verbose_print "done\n"

######################################################################
### comparison binaries against pkgsrc tree
verbose_print "  pkg_src_summary vs. pkg_summary comparison..."

eval @libexecdir@/wrapper \
    $PKG_CMP_SUMMARY_CMD "$pkg_src_summary_fn" "$PKG_ALL_SUMMARY" \
    > "$summary_cmp_fn" || true

if grep '^<' "$summary_cmp_fn" > /dev/null; then
    cat >> "$errors_fn" <<'EOF'
 ------------------
Versions of some packages go backward

EOF
    grep '^<' $summary_cmp_fn >> "$errors_fn"
fi

verbose_print "done\n"

######################################################################
### list of already built packages

verbose_print "  copying auxiliary files..."

cp "$reqd_deps_fn"           "$aux_reqd_deps_fn"

verbose_print "done\n"

######################################################################
